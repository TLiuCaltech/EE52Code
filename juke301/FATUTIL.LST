iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   1


DOS 5.0 (038-N) iC-86 COMPILER V4.0, COMPILATION OF MODULE FATUTIL
OBJECT MODULE PLACED IN FATUTIL.OBJ
COMPILER INVOKED BY: C:\5XTOOLS\IC86.EXE FATUTIL.C DEBUG MOD186 EXTEND CODE SMALL ROM NOALIGN

 line level  incl 

    1             /****************************************************************************/
    2             /*                                                                          */
    3             /*                                 FATUTIL                                  */
    4             /*              Utility Functions for Reading a FAT16 Hard Drive            */
    5             /*                           MP3 Jukebox Project                            */
    6             /*                                EE/CS 52                                  */
    7             /*                                                                          */
    8             /****************************************************************************/
    9             
   10             /*
   11                This file contains utility functions for reading a FAT16 hard drive.  The
   12                current directory information and the path are kept locally in this file.
   13                The functions included are:
   14                   cur_isDir              - is the current file a directory
   15                   cur_isParentDir        - is the current file the parent directory (..)
   16                   get_cur_file_attr      - get the attributes of the current file
   17                   get_cur_file_name      - get the name of the current file
   18                   get_cur_file_sector    - get the starting sector of the current file
   19                   get_cur_file_size      - get the size in bytes of the current file
   20                   get_cur_file_time      - get the time of the current file
   21                   get_file_blocks        - get data blocks from the current file
   22                   get_first_dir_entry    - get the first file in the current directory
   23                   get_ID3_tag            - get the possible ID3 tag for the current file
   24                   get_next_dir_entry     - get next file in the current directory
   25                   get_partition_start    - get the start of the current partition
   26                   get_previous_dir_entry - get previous file in the current directory
   27                   init_FAT_system        - initialize the FAT file system
   28             
   29                The local functions included are:
   30                   get_block_info         - get file FAT information for a block
   31                   get_contig_sectors     - get contiguous sectors of a file
   32                   get_dir_tos_name       - get name on the top of the stack
   33                   get_dir_tos_sector     - get starting sector of directory at tos
   34                   get_disk_blocks        - get sectors of a file from the disk
   35                   get_file_info          - fill in passed structure with file information
   36                   init_dir_stack         - initialize the directory name stack
   37                   new_directory          - entering a new directory, update the stack
   38             
   39                The locally global variable definitions included are:
   40                   cur_dir                - current file entry in dir_sector[]
   41                   cur_info               - file information of current directory entry
   42                   dir_info               - file information of current directory
   43                   dir_offset             - current sector offset in the current directory
   44                   dir_sector             - array of directory entries in a sector
   45                   dirclusterstack        - stack of starting directory cluster numbers
   46                   dirname                - name of current directory
   47                   dirnames               - names of directories on stack as a char []
   48                   dirnamestack           - stack of name positions in dirnames[]
   49                   dirstack_ptr           - the stack pointer into directory info stacks
   50                   fat16                  - flag indicating FAT16 or FAT32 disk
   51                   filename               - filename of current directory entry
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   2


   52                   first_FAT_sector       - sector number of the start of the first FAT
   53                   first_file_sector      - sector of the first file on the hard drive
   54                   partition_start        - starting sector of the first partition
   55                   root_dir_size          - size of the root directory in sectors (FAT16)
   56                   root_start_sector      - starting sector of root directory (FAT16)
   57                   sectors_per_cluster    - number of sectors per cluster
   58             
   59             
   60                Revision History
   61                   6/5/03   Glen George       Initial revision.
   62                   6/10/03  Glen George       Updated get_cur_file_time() to use macros
   63                                              to extract the hours/minutes/seconds from a
   64                                              word in the directory entry, rather than bit
   65                                              fields which aren't convenient in Intel C.
   66                   6/10/03  Glen George       Changed code to not display volume label
   67                                              entries and instead use them as the name of
   68                                              the root directory.
   69                   6/10/03  Glen George       Updated comments.
   70                   6/11/03  Glen George       Changed code to use new packed int time and
   71                                              date structure for directory entries.
   72                   6/11/03  Glen George       Fixed minor problem with unterminated
   73                                              comment.
   74                   4/29/06  Glen George       Removed inclusion of string.h, that's handled
   75                                              by mp3defs.h now.
   76                   4/29/06  Glen George       Changed all calls to get_blocks to use words
   77                                              (short int) instead of bytes (char).
   78                   4/29/06  Glen George       Switched to using unions and macros for
   79                                              accessing hard drive data for portability.
   80                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   81                                              for portability.
   82                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   83                                              for portability.
   84                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   85                                              for portability.
   86                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   87                                              for portability.
   88                   6/5/08   Glen George       Modified to also read the partition table to
   89                                              get the start of the first partition.  Mainly
   90                                              adds the shared variable partition_start
   91                                              which is added to all hard drive sector
   92                                              numbers.
   93                   6/12/08  Glen George       Fixed calculation of start of the partition -
   94                                              there was a parenthesis error and a
   95                                              portability problem.
   96                   6/19/08  Glen George       Added accessor method get_partition_start()
   97                                              for getting the start of the partition.
   98                   3/16/13  Glen George       Fixed bug in get_previous_dir_entry()
   99                                              function where it would backup by two entries
  100                                              if files didn't have long filenames.
  101                   3/17/13  Glen George       Changed interfaces for init_FAT_system() and
  102                                              get_first_dir_entry() functions.
  103                   3/17/13  Glen George       Added get_ID3_tag() and get_file_blocks()
  104                                              functions to support reading ID3 tags and
  105                                              fragmented files.
  106                   3/17/13  Glen George       Added numerous variables and local functions
  107                                              to support fragmented files and FAT32.
  108                   3/21/13  Glen George       Fixed problem with 0 length FAT caches.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   3


  109                   3/24/13  Glen George       Fixed problem with not setting up the FAT16
  110                                              root directory information correctly when
  111                                              move back into the directory.
  112                   4/3/13   Glen George       Fixed bug in get_previous_dir_entry()
  113                                              function.
  114                   4/5/13   Glen George       Fixed bug in how the far pointer is formed,
  115                                              it was crossing a segment boundary.
  116             */
  117             
  118             
  119             
  120             
  121             /* library include files */
  122             #ifdef  PCVERSION
                  #endif
  125             
  126             /* local include files */
  127             #include  "mp3defs.h"
  128             #include  "interfac.h"
  129             #include  "vfat.h"
  130             #include  "fatutil.h"
  131             
  132             
  133             
  134             
  135             /* local definitions */
  136               /* none */
  137             
  138             
  139             
  140             
  141             /* local function declarations */
  142             void                get_block_info(struct block_info *, unsigned long int);     /* get file FAT inform
                -ation */
  143             unsigned long int   get_contig_sectors(unsigned long int, struct cache_entry *);   /* get contiguous s
                -ectors of file */
  144             int                 get_disk_blocks(struct block_info *, unsigned long int,
  145                                                 int, unsigned short int far *);     /* get blocks from disk */
  146             void                init_dir_stack(void);       /* initialize stack of directory names */
  147             void                new_directory(void);        /* entering a new directory, update stack */
  148             const char         *get_dir_tos_name(void);     /* get name of directory at top of stack */
  149             unsigned long int   get_dir_tos_sector(void);   /* get starting sector of directory at top of stack */
  150             
  151             
  152             
  153             
  154             /* locally global variables */
  155             
  156             /* local variables shared by directory functions */
  157             
  158             static  union  VFAT_dir_entry  dir_sector[ENTRIES_PER_SECTOR];  /* directory entries in a sector */
  159             static  int                    cur_dir;             /* current entry in dir_sector[] */
  160             
  161             static  struct  block_info     dir_info;            /* current directory information */
  162             static  unsigned long int      dir_offset;          /* sector offset in directory */
  163             
  164             static  char  dirname[MAX_LFN_LEN];                 /* name of current directory */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   4


  165             
  166             
  167             /* information about current file */
  168             
  169             static  struct  block_info     cur_info;            /* current file information */
  170             
  171             static  char  filename[MAX_LFN_LEN];                /* filename of current entry */
  172             
  173             
  174             /* general drive variables */
  175             
  176             static  char                   fat16;               /* whether FAT16 or FAT32 disk */
  177             
  178             static  long int               sectors_per_cluster; /* number of sectors per cluster */
  179             static  int                    clusters_per_sector; /* number of clusters per sector in FAT */
  180             
  181             static  unsigned long int      partition_start;     /* starting sector number of the first partition *
                -/
  182             static  unsigned long int      first_FAT_sector;    /* sector number of the start of the first FAT */
  183             static  unsigned long int      first_file_sector;   /* sector of the first file on the hard drive */
  184             static  unsigned long int      root_start_sector;   /* starting sector of root directory (FAT 16) */
  185             static  long int               root_dir_size;       /* size of root directory (FAT16) */
  186             
  187             static  struct cache_entry  far  *FAT_cache;        /* cache of FAT entries */
  188             
  189             
  190             
  191             
  192             /*
  193                init_FAT_system()
  194             
  195                Description:      This function initializes FAT file system.
  196                        
  197                Operation:        The function reads the partition table and boot record to
  198                                  set up the directory parameters: the starting sector
  199                                  number for files on the drive, and the number of sectors
  200                                  per cluster.  It also initializes the directory stack and
  201                                  the directory name and filename.
  202             
  203                Arguments:        None.
  204                Return Value:     (char) - TRUE (non-zero) if there is an error and FALSE
  205                                  (zero) if not.
  206             
  207                Inputs:           None.
  208                Outputs:          None.
  209             
  210                Error Handling:   If there is an error reading the drive or interpretting
  211                                  the data, a non-zero value is returned.
  212             
  213                Algorithms:       None.
  214                Data Structures:  None.
  215             
  216                Shared Variables: clusters_per_sector - set based on the FAT type.
  217                                  cur_info            - set to the information for the
  218                                                        root directory.
  219                                  dirname             - set to the read volume label.
  220                                  FAT_cache           - set to point at the cache.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   5


  221                                  fat16               - set to the read filesystem type.
  222                                  filename            - set to the empty string.
  223                                  first_FAT_sector    - set to computed sector number.
  224                                  first_file_sector   - set to the computed sector number.
  225                                  partition_start     - starting sector number of the
  226                                                        partition.
  227                                  root_dir_size       - set to the read size of the root
  228                                                        directory (FAT16 only).
  229                                  root_start_sector   - set to the starting sector of the
  230                                                        root directory (FAT16 only).
  231                                  sectors_per_cluster - set to the read sectors per
  232                                                        cluster.
  233             
  234                Author:           Glen George
  235                Last Modified:    April 5, 2013
  236             
  237             */
  238             
  239             char  init_FAT_system()
  240             {
  241     1           /* variables */
  242     1           union  first_sector   s;            /* the boot sector */
  243     1       
  244     1           char                 *vid;          /* volume ID string */
  245     1       
  246     1           char                  error;        /* drive reading error flag */
  247     1       
  248     1           int                   i;            /* general loop index */
  249     1       
  250     1       
  251     1       
  252     1           /* setup the FAT cache - just make it point at memory for it */
  253     1           /* allocate the buffer (different on PC vs. embedded system) */
  254     1       #ifdef  PCVERSION
                  #else
  258     1           /* embedded version, FAT cache comes after the audio buffers */
  259     1           /*    note that this can cause a segment boundary to be crossed so need */
  260     1           /*    to do the calculation in the segment number just in case */
  261     1           FAT_cache = (struct cache_entry far *) MAKE_FARPTR(DRAM_STARTSEG +
  262     1                          ((NO_BUFFERS + 1L) * BUFFER_SIZE * sizeof(short int)) / 16L, 0);
  263     1       #endif
  264     1       
  265     1       
  266     1           /* read the first sector from the harddrive to get the partition table */
  267     1           error = (get_blocks(0, 1, (unsigned short int far *) &s) != 1);
  268     1       
  269     1           /* compute and store the starting sector of the first partition */
  270     1           partition_start = ((unsigned long int) s.words[PARTITION_START_LO] & 0xFFFFUL) +
  271     1                             (((unsigned long int) s.words[PARTITION_START_HI] & 0xFFFFUL) << 16);
  272     1       
  273     1           /* determine partition type (in low byte) - just check if FAT16 */
  274     1           fat16 = ((s.words[PARTITION_TYPE] & 0xFF) == PARTITION_FAT16);
  275     1       
  276     1       
  277     1           /* now read the first sector of the partition from the harddrive */
  278     1           /* retrieves the BIOS Parameter Block (assuming no errors) */
  279     1           error = error || (get_blocks(partition_start, 1, (unsigned short int far *) &s) != 1);
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   6


  280     1       
  281     1       
  282     1           /* set parameters that are independent of FAT type */
  283     1       
  284     1           /* get the starting sector for the first FAT */
  285     1           first_FAT_sector = partition_start + RESERVED_SECTORS(s);
  286     1           /* get the sectors per cluster */
  287     1           sectors_per_cluster = ALLOC_SECTORS(s);
  288     1       
  289     1       
  290     1           /* compute the root directory information (depends on FAT type) */
  291     1           if (fat16)  {
  292     2       
  293     2               /* get the start of the root directory (sector number) for FAT16 */
  294     2               root_start_sector = partition_start + RESERVED_SECTORS(s) +
  295     2                                   (NUMFATS(s) * FAT_SECTORS_16(s));
  296     2               /* get the root directory size as well */
  297     2               root_dir_size = (ROOT_ENTRIES(s) / ENTRIES_PER_SECTOR);
  298     2       
  299     2               /* get the starting sector for files */
  300     2               first_file_sector = root_start_sector + root_dir_size;
  301     2       
  302     2               /* get the start of the volume label */
  303     2               vid = VOLUME_ID_16(s);
  304     2       
  305     2               /* set clusters per sector in the FAT (1 word per entry) */
  306     2               clusters_per_sector = IDE_BLOCK_SIZE;
  307     2       
  308     2               /* set first cluster number to 0 to indicate fixed root directory */
  309     2               cur_info.cluster1 = 0;
  310     2           }
  311     1           else  {
  312     2       
  313     2               /* for FAT32 there is no fixed root directory */
  314     2               root_start_sector = 0;
  315     2               root_dir_size = 0;
  316     2       
  317     2               /* get the starting sector for files */
  318     2               first_file_sector = partition_start + RESERVED_SECTORS(s) +
  319     2                                   (NUMFATS(s) * FAT_SECTORS_32(s));
  320     2       
  321     2               /* get the start of the volume label */
  322     2               vid = VOLUME_ID_32(s);
  323     2       
  324     2               /* set clusters per sector in the FAT (2 words per entry) */
  325     2               clusters_per_sector = IDE_BLOCK_SIZE / 2;
  326     2       
  327     2               /* for FAT32 have to get the first root cluster from boot record */
  328     2               cur_info.cluster1 = ROOT_CLUSTER(s);
  329     2           }
  330     1       
  331     1       
  332     1           /* not using FAT cache yet */
  333     1           cur_info.cache_idx = -1;
  334     1           /* and point to end of file so will reset to beginning */
  335     1           cur_info.offset = 0xFFFFFFFF;
  336     1           /* get the information for the root directory */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   7


  337     1           get_block_info(&cur_info, 0);
  338     1       
  339     1       
  340     1           /* set the directory name to the volume label and the filename to blank */
  341     1           for (i = 0; i < VOL_LABEL_LEN; i++)
  342     1               dirname[i] = vid[i];
  343     1           /* make sure directory name is <null> terminated */
  344     1           dirname[VOL_LABEL_LEN] = '\0';
  345     1           /* and blank the filename */
  346     1           filename[0] = '\0';
  347     1       
  348     1       
  349     1           /* verify there are 512 bytes per sector (all code assumes this) */
  350     1           error = error || (SECTOR_SIZE(s) != 512);
  351     1       
  352     1       
  353     1           /* if there was an error set everything to default values */
  354     1           if (error)  {
  355     2       
  356     2               /* there was an error - set some parameters to default values */
  357     2               first_file_sector = 1;
  358     2               first_FAT_sector = 1;
  359     2               sectors_per_cluster = 64;
  360     2           }
  361     1       
  362     1       
  363     1           /* initialize the directory name stack */
  364     1           init_dir_stack();
  365     1       
  366     1       
  367     1           /* and return the error status */
  368     1           return  error;
  369     1       
  370     1       }
  371             
  372             
  373             
  374             
  375             /*
  376                get_partition_start
  377             
  378                Description:      This function returns the starting sector number of the
  379                                  current partition.
  380             
  381                Arguments:        None.
  382                Return Value:     (unsigned long int) - starting sector number of the
  383                                  current partition.
  384             
  385                Inputs:           None.
  386                Outputs:          None.
  387             
  388                Error Handling:   None.
  389             
  390                Algorithms:       None.
  391                Data Structures:  None.
  392             
  393                Shared Variables: partition_start - accessed by this function.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   8


  394             
  395                Author:           Glen George
  396                Last Modified:    June 19, 2008
  397             
  398             */
  399             
  400             unsigned long int  get_partition_start()
  401             {
  402     1           /* variables */
  403     1             /* none */
  404     1       
  405     1       
  406     1       
  407     1           /* just return the current start of the parition */
  408     1           return  partition_start;
  409     1       
  410     1       }
  411             
  412             
  413             
  414             
  415             /*
  416                get_cur_file_name
  417             
  418                Description:      This function returns a pointer to the name of the
  419                                  current directory entry (a filename).
  420             
  421                Arguments:        None.
  422                Return Value:     (const char *) - pointer to the name of the current
  423                                  directory entry.  If the entry has a long filename that
  424                                  filename is returned, otherwise the 8.3 filename is
  425                                  returned.  If there is no current directory, due to an
  426                                  error, and empty string is returned.
  427             
  428                Inputs:           None.
  429                Outputs:          None.
  430             
  431                Error Handling:   None.
  432             
  433                Algorithms:       None.
  434                Data Structures:  None.
  435             
  436                Shared Variables: filename - accessed by this function.
  437             
  438                Author:           Glen George
  439                Last Modified:    June 1, 2003
  440             
  441             */
  442             
  443             const char  *get_cur_file_name()
  444             {
  445     1           /* variables */
  446     1             /* none */
  447     1       
  448     1       
  449     1       
  450     1           /* just return a pointer to the current filename */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE   9


  451     1           return  filename;
  452     1       
  453     1       }
  454             
  455             
  456             
  457             
  458             /*
  459                get_cur_file_attr
  460             
  461                Description:      This function returns the attribute byte of the current
  462                                  directory entry.
  463             
  464                Arguments:        None.
  465                Return Value:     (unsigned char) - attribute byte of the current directory
  466                                  entry (a file).  If there is no current directory entry
  467                                  due to an error, zero is returned.
  468             
  469                Inputs:           None.
  470                Outputs:          None.
  471             
  472                Error Handling:   None.
  473             
  474                Algorithms:       None.
  475                Data Structures:  None.
  476             
  477                Shared Variables: dir_sector - accessed to determine attribute.
  478                                  cur_dir    - accessed to determine current attribute.
  479             
  480                Author:           Glen George
  481                Last Modified:    April 29, 2006
  482             
  483             */
  484             
  485             unsigned char  get_cur_file_attr()
  486             {
  487     1           /* variables */
  488     1             /* none */
  489     1       
  490     1       
  491     1       
  492     1           /* just return the attribute of the current directory entry */
  493     1           return  ATTR(dir_sector[cur_dir]);
  494     1       
  495     1       }
  496             
  497             
  498             
  499             
  500             /*
  501                cur_isDir
  502             
  503                Description:      This function returns whether or not the current file
  504                                  entry is a subdirectory.
  505             
  506                Arguments:        None.
  507                Return Value:     (char) - TRUE if the current entry is a subdirectory,
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  10


  508                                  FALSE if it is not.
  509             
  510                Inputs:           None.
  511                Outputs:          None.
  512             
  513                Error Handling:   None.
  514             
  515                Algorithms:       None.
  516                Data Structures:  None.
  517             
  518                Shared Variables: dir_sector - accessed to determine directory status.
  519                                  cur_dir    - accessed to determine directory status.
  520             
  521                Author:           Glen George
  522                Last Modified:    June 27, 2002
  523             
  524             */
  525             
  526             char  cur_isDir()
  527             {
  528     1           /* variables */
  529     1             /* none */
  530     1       
  531     1       
  532     1       
  533     1           /* just return whether or not current entry is a directory */
  534     1           return  ((get_cur_file_attr() & ATTRIB_DIR) != 0);
  535     1       
  536     1       }
  537             
  538             
  539             
  540             
  541             /*
  542                cur_isParentDir
  543             
  544                Description:      This function returns whether or not the current file
  545                                  entry is the parent directory.
  546             
  547                Arguments:        None.
  548                Return Value:     (char) - TRUE if the current entry is the parent
  549                                  directory (".."), FALSE if it is not.
  550             
  551                Inputs:           None.
  552                Outputs:          None.
  553             
  554                Error Handling:   None.
  555             
  556                Algorithms:       None.
  557                Data Structures:  None.
  558             
  559                Shared Variables: dir_sector - accessed to determine directory status.
  560                                  cur_dir    - accessed to determine directory status.
  561             
  562                Author:           Glen George
  563                Last Modified:    April 29, 2006
  564             
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  11


  565             */
  566             
  567             char  cur_isParentDir()
  568             {
  569     1           /* variables */
  570     1             /* none */
  571     1       
  572     1       
  573     1       
  574     1           /* just return whether or not current entry is the parent directory */
  575     1           /* it's the parent if the name starts with '.' */
  576     1           return  (cur_isDir() && (FILENAME(dir_sector[cur_dir], 0) == '.'));
  577     1       
  578     1       }
  579             
  580             
  581             
  582             
  583             /*
  584                get_cur_file_time
  585             
  586                Description:      This function returns the time (in seconds) of the
  587                                  current directory entry (a file).
  588             
  589                Arguments:        None.
  590                Return Value:     (unsigned int) - the time stamp for the current
  591                                  directory entry in seconds.  If there is no current
  592                                  directory entry due to an error, zero is returned.
  593             
  594                Inputs:           None.
  595                Outputs:          None.
  596             
  597                Error Handling:   None.
  598             
  599                Algorithms:       None.
  600                Data Structures:  None.
  601             
  602                Shared Variables: dir_sector - accessed by this function.
  603                                  cur_dir    - accessed by this function.
  604             
  605                Author:           Glen George
  606                Last Modified:    April 29, 2006
  607             
  608             */
  609             
  610             unsigned int  get_cur_file_time()
  611             {
  612     1           /* variables */
  613     1           unsigned int  t;            /* the file time (in seconds) */
  614     1       
  615     1       
  616     1       
  617     1           /* first get the seconds (kept in units of 2 seconds) */
  618     1           t = 2 * DIR_SECONDS(FTIME(dir_sector[cur_dir]));
  619     1           /* then add in the minutes and hours */
  620     1           t += 60 * DIR_MINUTES(FTIME(dir_sector[cur_dir]));
  621     1           t += 60 * 60 * DIR_HOURS(FTIME(dir_sector[cur_dir]));
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  12


  622     1       
  623     1       
  624     1           /* and return the resulting time in seconds */
  625     1           return  t;
  626     1       
  627     1       }
  628             
  629             
  630             
  631             
  632             /*
  633                get_cur_file_size
  634             
  635                Description:      This function returns the size of the current directory
  636                                  entry (a file) in bytes.
  637             
  638                Arguments:        None.
  639                Return Value:     (unsigned long int) - size (in bytes) of the current
  640                                  directory entry.  If there is no current directory entry
  641                                  due to an error, zero is returned.
  642             
  643                Inputs:           None.
  644                Outputs:          None.
  645             
  646                Error Handling:   None.
  647             
  648                Algorithms:       None.
  649                Data Structures:  None.
  650             
  651                Shared Variables: dir_sector - accessed by this function.
  652                                  cur_dir    - accessed by this function.
  653             
  654                Author:           Glen George
  655                Last Modified:    April 29, 2006
  656             
  657             */
  658             
  659             long int  get_cur_file_size()
  660             {
  661     1           /* variables */
  662     1             /* none */
  663     1       
  664     1       
  665     1       
  666     1           /* return the length in bytes of the current directory entry */
  667     1           return  FSIZE(dir_sector[cur_dir]);
  668     1       
  669     1       }
  670             
  671             
  672             
  673             
  674             /*
  675                get_cur_file_sector
  676             
  677                Description:      This function returns the starting sector of the current
  678                                  directory entry (a file).
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  13


  679             
  680                Arguments:        None.
  681                Return Value:     (unsigned long int) - starting sector of the current
  682                                  directory entry.  If there is no current directory entry
  683                                  due to an error, zero is returned.
  684             
  685                Inputs:           None.
  686                Outputs:          None.
  687             
  688                Error Handling:   None.
  689             
  690                Algorithms:       None.
  691                Data Structures:  None.
  692             
  693                Shared Variables: cur_info            - accessed by this function.
  694                                  first_file_sector   - accessed by this function.
  695                                  sectors_per_cluster - accessed by this function.
  696             
  697                Author:           Glen George
  698                Last Modified:    March 17, 2013
  699             
  700             */
  701             
  702             unsigned long int  get_cur_file_sector()
  703             {
  704     1           /* variables */
  705     1             /* none */
  706     1       
  707     1       
  708     1       
  709     1           /* return the starting sector of the current directory entry */
  710     1           /* watch for FAT16 root directory */
  711     1           if (cur_info.cluster1 == 0)
  712     1               /* FAT16 root directory, return its starting sector */
  713     1               return  root_start_sector;
  714     1           else
  715     1               /* not FAT16 root directory, compute and return starting sector */
  716     1               return  first_file_sector + (cur_info.cluster1 - 2) * sectors_per_cluster;
  717     1       
  718     1       }
  719             
  720             
  721             
  722             
  723             /*
  724                get_ID3_tag
  725             
  726                Description:      This function reads the ID3 tag into the passed buffer.
  727                                  It just reads the last ID3_TAG_SIZE bytes of the current
  728                                  file into the passed buffer.
  729             
  730                Arguments:        buffer (char *) - buffer into which the the ID3 tag is to
  731                                                    be read.
  732                Return Value:     None.
  733             
  734                Input:            None.
  735                Output:           None.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  14


  736             
  737                Error Handling:   None.
  738             
  739                Algorithms:       None.
  740                Data Structures:  None.
  741             
  742                Shared Variables: None.
  743             
  744                Author:           Glen George
  745                Last Modified:    March 17, 2013
  746             
  747             */
  748             
  749             void  get_ID3_tag(char *buffer)
  750             {
  751     1           /* variables */
  752     1           char  s[IDE_BLOCK_SIZE * 2];        /* sector from the hard drive */
  753     1       
  754     1           int   sector;                       /* sector where ID3 tag starts */
  755     1           int   offset;                       /* offset within sector for ID3 tag */
  756     1       
  757     1           char  error;                        /* error reading the file */
  758     1       
  759     1           int   i;                            /* general loop index */
  760     1       
  761     1       
  762     1       
  763     1           /* get the sector number of the start of the ID3 tag and its offset */
  764     1           /* the ID3 tag is at the end of the file (doing byte calculations) */
  765     1           sector = (get_cur_file_size() - ID3_TAG_SIZE) / (2 * IDE_BLOCK_SIZE);
  766     1           offset = (get_cur_file_size() - ID3_TAG_SIZE) % (2 * IDE_BLOCK_SIZE);
  767     1       
  768     1       
  769     1           /* try to read a sector from the harddrive to get the ID3 tag */
  770     1           error = (get_file_blocks(sector, 1, (unsigned short int far *) s) != 1);
  771     1       
  772     1           /* now fill the tag with the data read watching for errors */
  773     1           for (i = 0; (!error && (i < ID3_TAG_SIZE)); i++, offset++)  {
  774     2       
  775     2               /* check if past the end of the sector (working with bytes, not words) */
  776     2               if (offset >= (2 * IDE_BLOCK_SIZE))  {
  777     3                   /* past the end of this sector, need to read next sector */
  778     3                   error = (get_file_blocks(++sector, 1, (unsigned short int far *) s) != 1);
  779     3                   /* and at the start of this new sector */
  780     3                   offset = 0;
  781     3               }
  782     2       
  783     2               /* can always copy a byte, even if there was an error */
  784     2               buffer[i] = s[offset];
  785     2           }
  786     1       
  787     1       
  788     1           /* if there was an error reading the tag, clear out the tag */
  789     1           if (error)  {
  790     2               /* there was an error, fill tag with <null> */
  791     2               for (i = 0; i < ID3_TAG_SIZE; i++)
  792     2                   buffer[i] = '\0';
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  15


  793     2           }
  794     1       
  795     1       
  796     1           /* all done reading the ID3 tag, return */
  797     1           return;
  798     1       
  799     1       }
  800             
  801             
  802             
  803             
  804             /*
  805                get_file_blocks
  806             
  807                Description:      This function reads blocks from the current file.  The
  808                                  data "read" is written to the memory pointed to by the
  809                                  third argument.  The number of blocks requested is given
  810                                  as the second argument.  The starting block number in the
  811                                  file to read is passed as the first argument.  The
  812                                  function just calls get_disk_blocks() with the current
  813                                  file block information to read the actual hard drive.
  814             
  815                Arguments:        block (unsigned long int)       - sector number (relative
  816                                                                    to the start of the
  817                                                                    file) at which to start
  818                                                                    reading.
  819                                  length (int)                    - number of blocks to be
  820                                                                    read.
  821                                  dest (unsigned short int far *) - pointer to the memory
  822                                                                    where the read data is
  823                                                                    to be written.
  824                Return Value:     The number of blocks actually read.
  825             
  826                Input:            None.
  827                Output:           None.
  828             
  829                Error Handling:   None.
  830             
  831                Algorithms:       None.
  832                Data Structures:  None.
  833             
  834                Shared Variables: None.
  835             
  836                Author:           Glen George
  837                Last Modified:    March 17, 2013
  838             
  839             */
  840             
  841             int  get_file_blocks(unsigned long int block, int length, unsigned short int far *dest)
  842             {
  843     1           /* variables */
  844     1             /* none */
  845     1       
  846     1       
  847     1       
  848     1           /* just call the get_disk_blocks function and return its result */
  849     1           return  get_disk_blocks(&cur_info, block, length, dest);
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  16


  850     1       
  851     1       }
  852             
  853             
  854             
  855             
  856             /*
  857                get_first_dir_entry
  858             
  859                Description:      This function gets the first valid directory entry in
  860                                  the directory whose starting sector number is that of the
  861                                  current file.  The long filename of this directory entry
  862                                  is also read and the filename variable is set to this
  863                                  long filename if it exists or the 8.3 filename if there
  864                                  is no long filename.  Finally the starting sector number
  865                                  of this entry is also saved and that FAT cache is filled
  866                                  with information for this file.  If there is an error
  867                                  reading the directory entry the filename is set to the
  868                                  empty string, the starting sector number is set to 0, the
  869                                  directory information is properly initialized, and TRUE
  870                                  is returned.  The function get_next_dir_entry is used to
  871                                  actually get the first directory entry.
  872             
  873                Arguments:        None.
  874                Return Value:     (char) - TRUE if there is an error reading the directory
  875                                  information, FALSE otherwise.
  876             
  877                Inputs:           Data is read from the disk drive.
  878                Outputs:          None.
  879             
  880                Error Handling:   If there is an error reading the directory, the saved
  881                                  information is set to reasonable values and TRUE is
  882                                  returned.
  883             
  884                Algorithms:       None.
  885                Data Structures:  None.
  886             
  887                Shared Variables: cur_dir    - set to the current file entry.
  888                                  cur_info   - set to the info for current file entry.
  889                                  dir_info   - set to the current value of cur_info.
  890                                  dir_offset - set to zero (0), 1st sector of directory.
  891                                  dir_sector - filled with a sector of directory entries.
  892                                  dirname    - set to the old value of filename.
  893                                  filename   - set to the filename of the current entry.
  894             
  895                Author:           Glen George
  896                Last Modified:    March 17, 2013
  897             
  898             */
  899             
  900             char  get_first_dir_entry()
  901             {
  902     1           /* variables */
  903     1           char  error = FALSE;        /* read error flag */
  904     1       
  905     1       
  906     1       
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  17


  907     1           /* first save the current directory information */
  908     1           new_directory();
  909     1       
  910     1           /* now entering a directory, so save it as the directory name */
  911     1           strcpy(dirname, filename);
  912     1       
  913     1           /* and set the block information for the directory */
  914     1           dir_info.sector   = cur_info.sector;
  915     1           dir_info.size     = cur_info.size;
  916     1           dir_info.next     = cur_info.next;
  917     1           dir_info.offset   = cur_info.offset;
  918     1           dir_info.cluster1 = cur_info.cluster1;
  919     1           /* directories never cache their FAT information */
  920     1           dir_info.cache_idx = -1;
  921     1       
  922     1       
  923     1           /* setup the directory variables for the get_next_dir_entry function */
  924     1           /* have to point at entry "before" first entry */
  925     1           cur_dir = ENTRIES_PER_SECTOR - 1;   /* point at end of previous sector */
  926     1           dir_offset = -1;                    /* will be updated to 0 */
  927     1       
  928     1       
  929     1           /* now can just use the get_next_dir_entry function to get first file */
  930     1           error = get_next_dir_entry();
  931     1       
  932     1       
  933     1           /* done, return with the error status */
  934     1           return  error;
  935     1       
  936     1       }
  937             
  938             
  939             
  940             
  941             /*
  942                get_next_dir_entry
  943             
  944                Description:      This function gets the next valid directory entry in
  945                                  the directory.  As necessary it reads sectors of 
  946                                  directory entries from the hard drive.  The long filename
  947                                  of the next directory entry is also read and the filename
  948                                  variable is set to this long filename if it exists or the
  949                                  8.3 filename if it does not exist.  The current sector
  950                                  number and directory entry number are also updated.  The
  951                                  FAT cache is also filled with the information for this
  952                                  file.  If there is an error reading the directory entry
  953                                  the filename is set to the empty string, the starting
  954                                  sector number is set to 0, the directory information is
  955                                  properly initialized, and TRUE is returned.
  956             
  957                Arguments:        None.
  958                Return Value:     (char) - TRUE if there is an error reading the directory
  959                                  information, FALSE otherwise.
  960             
  961                Inputs:           Data is read from the disk drive.
  962                Outputs:          None.
  963             
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  18


  964                Error Handling:   If there is an error reading the directory, the saved
  965                                  information is set to reasonable values and TRUE is
  966                                  returned.
  967             
  968                Algorithms:       None.
  969                Data Structures:  None.
  970             
  971                Shared Variables: cur_dir             - accessed and updated to the current
  972                                                        entry.
  973                                  cur_info            - set to the FAT information for the
  974                                                        current directory entry.
  975                                  dir_info            - accessed to get the starting
  976                                                        cluster of the current directory.
  977                                  dir_offset          - accessed and possibly updated to
  978                                                        the sector offset of the directory
  979                                                        entries.
  980                                  dir_sector          - accessed and possibly filled with a
  981                                                        sector of directory entries.
  982                                  FAT_cache           - filled with the FAT chain for the
  983                                                        current directory entry.
  984                                  filename            - set to the filename of the current
  985                                                        entry.
  986                                  first_file_sector   - accessed to compute starting sector
  987                                                        of an entry.
  988                                  sectors_per_cluster - accessed to compute starting sector
  989                                                        of an entry.
  990             
  991                Author:           Glen George
  992                Last Modified:    March 24, 2013
  993             
  994             */
  995             
  996             char  get_next_dir_entry()
  997             {
  998     1           /* variables */
  999     1           char  longfilename[MAX_LFN_LEN];    /* long filename of current entry */
 1000     1           int   lfn_seq;                      /* sequence number for LFN */
 1001     1           int   chksum;                       /* long filename checksum */
 1002     1       
 1003     1           struct  cache_entry  e;             /* a FAT cache entry */
 1004     1           unsigned long int    next;          /* pointer to next FAT cluster */
 1005     1       
 1006     1           unsigned long int  old_dir_offset;  /* previous directory offset */
 1007     1           int                old_cur_dir;     /* old file entry in directory */
 1008     1       
 1009     1           char  error = FALSE;                /* read error flag */
 1010     1           char  done = FALSE;                 /* done reading the directory info */
 1011     1       
 1012     1           int   i;                            /* general loop indices */
 1013     1           int   k;
 1014     1       
 1015     1       
 1016     1       
 1017     1           /* reset the filename to setup for this file */
 1018     1           longfilename[0] = '\0';
 1019     1       
 1020     1           /* keep track of the old values (in case can't find a next entry */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  19


 1021     1           old_dir_offset = dir_offset;
 1022     1           old_cur_dir = cur_dir;
 1023     1       
 1024     1       
 1025     1           /* now find the next entry in this directory */
 1026     1           while (!error && !done)  {
 1027     2       
 1028     2               /* check if need to read a new sector's worth of entries */
 1029     2               if (cur_dir >= (ENTRIES_PER_SECTOR - 1))  {
 1030     3       
 1031     3                   /* need to read in a new sector of directory entries */
 1032     3                   /* update the directory sector number */
 1033     3                   dir_offset++;
 1034     3                   /* read a sector of directory entries, watching for an error */
 1035     3                   error = (get_disk_blocks(&dir_info, dir_offset, 1,
 1036     3                                      (unsigned short int far *) dir_sector) != 1);
 1037     3                   /* reset the pointer into the sector of entries */
 1038     3                   /* set to -1 so will be properly incremented in a couple lines */
 1039     3                   cur_dir = -1;
 1040     3               }
 1041     2       
 1042     2       
 1043     2               /* is this the first entry or the end of the directory */
 1044     2               if ((cur_dir == -1) || (FILENAME(dir_sector[cur_dir], 0) != '\0'))
 1045     2                   /* not end of the directory - update the entry number */
 1046     2                   cur_dir++;
 1047     2       
 1048     2       
 1049     2               /* try to find the next directory entry */
 1050     2               while (!error && !done && (cur_dir < ENTRIES_PER_SECTOR))  {
 1051     3       
 1052     3                   /* check if this is a long filename or a normal entry */
 1053     3                   if (ATTR(dir_sector[cur_dir]) == ATTRIB_LFN)  {
 1054     4       
 1055     4                       /* this is a long filename - collect characters */
 1056     4                       /* assume ASCII instead of Unicode */
 1057     4       
 1058     4                       /* get the sequence number for this part of the filename */
 1059     4                       /* make it zero-based */
 1060     4                       lfn_seq = (L_SEQ_NUM(dir_sector[cur_dir]) & LFN_SEQ_MASK) - 1;
 1061     4       
 1062     4                       /* collect the pieces of the long filename */
 1063     4                       for (k = 0; k < LFN_CHARS; k++)  {
 1064     5                           /* figure out where the LFN characters are */
 1065     5                           if (k < LFN1_CHARS)
 1066     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN1(dir_sector[cur_dir], 2 * k);
 1067     5                           else if (k < (LFN1_CHARS + LFN2_CHARS))
 1068     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN2(dir_sector[cur_dir], 2 * (k - L
                -FN1_CHARS));
 1069     5                           else
 1070     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN3(dir_sector[cur_dir], 2 * (k - L
                -FN1_CHARS - LFN2_CHARS));
 1071     5                       }
 1072     4       
 1073     4                       /* check if this is the last entry */
 1074     4                       if ((L_SEQ_NUM(dir_sector[cur_dir]) & LAST_LFN_ENTRY) != 0)  {
 1075     5                           /* last entry so remember the checksum */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  20


 1076     5                           chksum = CHECKSUM(dir_sector[cur_dir]);
 1077     5                           /* also terminate the filename */
 1078     5                           longfilename[LFN_CHARS * (lfn_seq + 1)] = '\0';
 1079     5                       }
 1080     4                       
 1081     4                       /* go to the next directory entry */
 1082     4                       cur_dir++;
 1083     4                   }
 1084     3                   else  {
 1085     4       
 1086     4                       /* this is a normal entry */
 1087     4                       /* first check if this entry really exists */
 1088     4                       if (FILENAME(dir_sector[cur_dir], 0) == '\xE5')  {
 1089     5       
 1090     5                           /* deleted entry */
 1091     5                           /* not a valid file, clear the long filename */
 1092     5                           longfilename[0] = '\0';
 1093     5                           /* and move to the next entry */
 1094     5                           cur_dir++;
 1095     5                       }
 1096     4       
 1097     4                       /* is it the end of directory marker */
 1098     4                       else if (FILENAME(dir_sector[cur_dir], 0) == '\0')  {
 1099     5       
 1100     5                           /* end of directory marker */
 1101     5                           /* not a valid file, clear the filename */
 1102     5                           longfilename[0] = '\0';
 1103     5                           /* need to restore the old file state (on last file) */
 1104     5                           cur_dir = old_cur_dir;
 1105     5                           /* check if need to restore the directory sector */
 1106     5                           if (dir_offset != old_dir_offset)  {
 1107     6                               /* need to restore the old directory sector */
 1108     6                               error = (get_disk_blocks(&dir_info, old_dir_offset, 1,
 1109     6                                            (unsigned short int far *) dir_sector) != 1);
 1110     6                               /* also restore the actual offset */
 1111     6                               dir_offset = old_dir_offset;
 1112     6                           }
 1113     5                           /* restored state, now we're done */
 1114     5                           done = TRUE;
 1115     5                       }
 1116     4       
 1117     4                       /* is it . or .. */
 1118     4                       else if (FILENAME(dir_sector[cur_dir], 0) == '.')  {
 1119     5       
 1120     5                           /* is it pointer to this directory or parent directory */
 1121     5                           if (FILENAME(dir_sector[cur_dir], 1) == '.')  {
 1122     6       
 1123     6                               /* pointer to parent directory */
 1124     6                               /* so get starting cluster number and parent name */
 1125     6                               cur_info.cluster1 = get_dir_tos_sector();
 1126     6                               strcpy(filename, get_dir_tos_name());
 1127     6       
 1128     6                               /* also need to fill in the rest of the block info */
 1129     6                               /* check whether this is the FAT16 root directory */
 1130     6                               if (cur_info.cluster1 == 0)  {
 1131     7                                   /* FAT16 root directory, handle it specially */
 1132     7                                   cur_info.sector = root_start_sector;
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  21


 1133     7                                   cur_info.size = root_dir_size;
 1134     7                                   cur_info.next = CHAIN_END;
 1135     7                               }
 1136     6                               else  {
 1137     7                                   /* not FAT16 root, get the directory information */
 1138     7                                   cur_info.next = get_contig_sectors(cur_info.cluster1, &e);
 1139     7                                   cur_info.sector = (e.cluster - 2) * sectors_per_cluster + first_file_secto
                -r;
 1140     7                                   cur_info.size = e.size;
 1141     7                               }
 1142     6       
 1143     6                               /* always at start of the directory */
 1144     6                               cur_info.offset = 0;
 1145     6                               /* and never use a cache for directories */
 1146     6                               cur_info.cache_idx = -1;
 1147     6       
 1148     6                               /* and we are done */
 1149     6                               done = TRUE;
 1150     6                           }
 1151     5                           else  {
 1152     6       
 1153     6                               /* pointer to current directory - skip it */
 1154     6                               /* not a valid file, clear the long filename */
 1155     6                               longfilename[0] = '\0';
 1156     6                               /* and move to the next entry */
 1157     6                               cur_dir++;
 1158     6                           }
 1159     5                       }
 1160     4       
 1161     4                       /* is it a volume label */
 1162     4                       else if ((ATTR(dir_sector[cur_dir]) & ATTRIB_VOLUME) != 0)  {
 1163     5       
 1164     5                           /* it is a volume label, see if already have a directory name */
 1165     5                           if (dirname[0] == '\0')  {
 1166     6       
 1167     6                               /* no directory name currently, use volume label */
 1168     6                               /* now check if there is a long filename (shouldn't be) */
 1169     6                               /* first compute the checksum for this entry */
 1170     6                               /* if checksum OK and there is a filename - keep it */
 1171     6                               if (longfilename[0] == '\0')  {
 1172     7       
 1173     7                                   /* no long filename, set the directory name from 8.3 name */
 1174     7                                   /* copy the filename and extension (but no .) */
 1175     7                                   /* start at first character of filename */
 1176     7                                   k = 0;
 1177     7                                   /* copy the full filename */
 1178     7                                   for (i = 0; (i < DOS_FILENAME_LEN); i++)
 1179     7                                       dirname[k++] = FILENAME(dir_sector[cur_dir], i);
 1180     7       
 1181     7                                   /* now append the extension */
 1182     7                                   for (i = 0; (i < DOS_EXTENSION_LEN); i++)
 1183     7                                       dirname[k++] = EXTENSION(dir_sector[cur_dir], i);
 1184     7       
 1185     7                                   /* finally, null terminate the string */
 1186     7                                   dirname[k] = '\0';
 1187     7                               }
 1188     6                               else  {
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  22


 1189     7       
 1190     7                                   /* have a long filename - save it as the  directory name */
 1191     7                                   strcpy(dirname, longfilename);
 1192     7                               }
 1193     6                           }
 1194     5                           else  {
 1195     6       
 1196     6                               /* already have a directory name so ignore volume label */
 1197     6                               /* means we cursored back up to the directory */
 1198     6                               ;
 1199     6                           }
 1200     5       
 1201     5                           /* in any case, erase any long file name */
 1202     5                           longfilename[0] = '\0';
 1203     5                           /* and move to the next entry (ignore volume label) */
 1204     5                           cur_dir++;
 1205     5                       }
 1206     4       
 1207     4                       /* none of the above, so must actually be a file */
 1208     4                       else  {
 1209     5       
 1210     5                           /* need to set the file information, FAT cache, and filename */
 1211     5                           /* get the starting cluster based on FAT type */
 1212     5                           if (fat16)
 1213     5                               next = START_CLUSTER(dir_sector[cur_dir]);
 1214     5                           else
 1215     5                               next = START_CLUSTER32(dir_sector[cur_dir]);
 1216     5       
 1217     5                           /* fill the FAT cache for this file */
 1218     5                           for (i = 0;
 1219     5                                ((i + 1) < (FAT_CACHE_SIZE / sizeof(struct cache_entry))) && (next != CHAIN_E
                -ND);
 1220     5                                i++)  {
 1221     6       
 1222     6                               /* get the contiguous sectors at current position */
 1223     6                               next = get_contig_sectors(next, &e);
 1224     6       
 1225     6                               /* add this entry to the cache */
 1226     6                               FAT_cache[i].cluster = e.cluster;
 1227     6                               FAT_cache[i].size = e.size;
 1228     6                           }
 1229     5       
 1230     5                           /* fill in last cache entry with the last next pointer */
 1231     5                           /*    but only if there is room in the FAT cache */
 1232     5                           if (i < (FAT_CACHE_SIZE / sizeof(struct cache_entry)))  {
 1233     6                               FAT_cache[i].cluster = next;
 1234     6                               FAT_cache[i].size = 0;
 1235     6                           }
 1236     5       
 1237     5                           /* now set up the block information */
 1238     5                           /* get the first cluster from the directory information */
 1239     5                           if (fat16)
 1240     5                               cur_info.cluster1 = START_CLUSTER(dir_sector[cur_dir]);
 1241     5                           else
 1242     5                               cur_info.cluster1 = START_CLUSTER32(dir_sector[cur_dir]);
 1243     5                           /* at start of file */
 1244     5                           cur_info.offset = 0;
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  23


 1245     5       
 1246     5                           /* get info from first two cache entries if they exist */
 1247     5                           if ((FAT_CACHE_SIZE / sizeof(struct cache_entry)) > 1)  {
 1248     6       
 1249     6                               /* the FAT cache exists - get info there */
 1250     6                               cur_info.sector = (FAT_cache[0].cluster - 2) * sectors_per_cluster + first_fil
                -e_sector;
 1251     6                               cur_info.size = FAT_cache[0].size;
 1252     6                               cur_info.next = FAT_cache[1].cluster;
 1253     6                               /* at start of FAT cache */
 1254     6                               cur_info.cache_idx = 0;
 1255     6                           }
 1256     5                           else  {
 1257     6       
 1258     6                               /* no FAT cache, so get information from hard drive */
 1259     6                               /* get the contiguous sectors at start of file position */
 1260     6                               cur_info.next = get_contig_sectors(cur_info.cluster1, &e);
 1261     6                               /* add this information to the file information */
 1262     6                               cur_info.sector = (e.cluster - 2) * sectors_per_cluster + first_file_sector;
 1263     6                               cur_info.size = e.size;
 1264     6                               /* no cache so no index */
 1265     6                               cur_info.cache_idx = -1;
 1266     6                           }
 1267     5       
 1268     5                           /* now check if there is a long filename */
 1269     5                           /* first compute the checksum for this entry */
 1270     5                           /* if checksum OK and there is a filename - keep it */
 1271     5                           if (longfilename[0] == '\0')  {
 1272     6       
 1273     6                               /* no long filename, set the filename from 8.3 name */
 1274     6                               /* copy the filename and extension */
 1275     6                               /* start at first character of filename */
 1276     6                               k = 0;
 1277     6                               /* copy the filename without the trailing spaces */
 1278     6                               for (i = 0; ((i < DOS_FILENAME_LEN) && (FILENAME(dir_sector[cur_dir], i) != ' 
                -')); i++)
 1279     6                                   filename[k++] = FILENAME(dir_sector[cur_dir], i);
 1280     6       
 1281     6                               /* add the '.' separating name and extension */
 1282     6                               filename[k++] = '.';
 1283     6       
 1284     6                               /* now add the extension, skipping trailing spaces */
 1285     6                               for (i = 0; ((i < DOS_EXTENSION_LEN) && (EXTENSION(dir_sector[cur_dir], i) != 
                -' ')); i++)
 1286     6                                   filename[k++] = EXTENSION(dir_sector[cur_dir], i);
 1287     6       
 1288     6                               /* finally, null terminate the string */
 1289     6                               filename[k] = '\0';
 1290     6                           }
 1291     5                           else  {
 1292     6       
 1293     6                               /* have a long filename - save it as the filename */
 1294     6                               strcpy(filename, longfilename);
 1295     6                           }
 1296     5       
 1297     5                           /* got to the next entry so set the done flag */
 1298     5                           done = TRUE;
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  24


 1299     5                       }
 1300     4                   }
 1301     3               }
 1302     2           }
 1303     1       
 1304     1       
 1305     1           /* check if there was an error */
 1306     1           if (error)  {
 1307     2               /* had an error - clear out the data */
 1308     2               /* clear the filename */
 1309     2               filename[0] = '\0';
 1310     2               /* set the file info to the first sector */
 1311     2               cur_info.sector    = first_file_sector;
 1312     2               cur_info.size      = sectors_per_cluster;
 1313     2               cur_info.next      = CHAIN_END;
 1314     2               cur_info.offset    = 0;
 1315     2               cur_info.cluster1  = 2;
 1316     2               cur_info.cache_idx = -1;
 1317     2           }
 1318     1       
 1319     1       
 1320     1           /* finally done, return with the error status */
 1321     1           return  error;
 1322     1       
 1323     1       }
 1324             
 1325             
 1326             
 1327             
 1328             /*
 1329                get_previous_dir_entry
 1330             
 1331                Description:      This function gets the previous valid directory entry in
 1332                                  the directory.  As necessary it reads sectors of 
 1333                                  directory entries from the hard drive.  The function
 1334                                  backs up through the directory to the first standard
 1335                                  directory entry prior the current one and then back
 1336                                  before any long filename for that entry.  The long
 1337                                  filename of the previous directory entry is also read and
 1338                                  the filename variable is set to this long filename if it
 1339                                  exists or the 8.3 filename if there is no long filename.
 1340                                  The current sector number and directory entry number are
 1341                                  also updated.  If there is an error reading the directory
 1342                                  entry the filename is set to the empty string, the
 1343                                  starting sector number is set to 0, the directory
 1344                                  information is properly initialized, and TRUE is
 1345                                  returned.
 1346             
 1347                Arguments:        None.
 1348                Return Value:     (char) - TRUE if there is an error reading the directory
 1349                                  information, FALSE otherwise.
 1350             
 1351                Inputs:           Data is read from the disk drive.
 1352                Outputs:          None.
 1353             
 1354                Error Handling:   If there is an error reading the directory, the saved
 1355                                  information is set to reasonable values and TRUE is
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  25


 1356                                  returned.
 1357             
 1358                Algorithms:       None.
 1359                Data Structures:  None.
 1360             
 1361                Shared Variables: cur_dir       - accessed and updated to the current
 1362                                                  entry.
 1363                                  cur_info      - set to the block information for the
 1364                                                  current entry.
 1365                                  dir_offset    - accessed and possibly updated to the
 1366                                                  sector offset of the directory entries.
 1367                                  dir_sector    - accessed and possibly filled with a
 1368                                                  sector of directory entries.
 1369                                  filename      - set to the filename of the current entry.
 1370             
 1371                Author:           Glen George
 1372                Last Modified:    April 3, 2013
 1373             
 1374             */
 1375             
 1376             char  get_previous_dir_entry()
 1377             {
 1378     1           /* variables */
 1379     1           unsigned long int  new_offset;      /* new directory sector offset */
 1380     1           int                new_entry;       /* new directory entry */
 1381     1       
 1382     1           char  error = FALSE;        /* read error flag */
 1383     1           char  done = FALSE;         /* done getting the previous directory info */
 1384     1           char  have_entry = FALSE;   /* have the entry (but maybe not the filename) */
 1385     1       
 1386     1       
 1387     1       
 1388     1           /* find the previous entry in this directory */
 1389     1           /* loop until find the entry or get an error */
 1390     1           while (!error && !done)  {
 1391     2       
 1392     2               /* check if need to read a new sector's worth of entries */
 1393     2               if (cur_dir == 0)  {
 1394     3       
 1395     3                   /* need to read in the previous sector of directory entries */
 1396     3                   /* check if out of directory entries */
 1397     3                   if (dir_offset == 0)  {
 1398     4                       /* out of directory entries - reset to the start */
 1399     4                       new_offset = 0;
 1400     4                       new_entry = 0;
 1401     4                       /* and done */
 1402     4                       done = TRUE;
 1403     4                   }
 1404     3                   else  {
 1405     4                       /* have a previous directory entry to check, read the */
 1406     4                       /*    sector of directory entries, watching for an error */
 1407     4                       error = (get_disk_blocks(&dir_info, --dir_offset, 1,
 1408     4                                        (unsigned short int far *) dir_sector) != 1);
 1409     4                       /* and reset to the last file entry in the directory */
 1410     4                       cur_dir = ENTRIES_PER_SECTOR - 1;
 1411     4                   }
 1412     3               }
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  26


 1413     2               else  {
 1414     3       
 1415     3                   /* still more files in this directory, just check the previous entry */
 1416     3                   cur_dir--;
 1417     3               }
 1418     2       
 1419     2       
 1420     2               /* if not an error or done, keep processing */
 1421     2               if (!done && !error)  {
 1422     3       
 1423     3                   /* check if have already found a previous entry */
 1424     3                   if (have_entry)  {
 1425     4       
 1426     4                       /* already found a previous entry, but need to skip its */
 1427     4                       /* potentional long filename too */
 1428     4                       if (ATTR(dir_sector[cur_dir]) != ATTRIB_LFN)  {
 1429     5                           /* not a long filename, must be done */
 1430     5                           done = TRUE;
 1431     5                       }
 1432     4                       else  {
 1433     5                           /* still part of a long filename for the entry */
 1434     5                           /* so remember that this is potentially where new entry will start */
 1435     5                           new_offset = dir_offset;
 1436     5                           new_entry = cur_dir;
 1437     5                       }
 1438     4                   }
 1439     3                   else  {
 1440     4       
 1441     4                       /* have not found a previous entry yet, is this one */
 1442     4                       /* ignore empty entries, deleted entries, long filenames, */
 1443     4                       /*    volume labels, and '.' directory */
 1444     4                       if ((FILENAME(dir_sector[cur_dir], 0) != '\0')  &&
 1445     4                            (FILENAME(dir_sector[cur_dir], 0) != '\xE5')  &&
 1446     4                            (ATTR(dir_sector[cur_dir]) != ATTRIB_LFN) &&
 1447     4                            (ATTR(dir_sector[cur_dir]) != ATTRIB_VOLUME) &&
 1448     4                            ((FILENAME(dir_sector[cur_dir], 0) != '.')  ||
 1449     4                             (FILENAME(dir_sector[cur_dir], 1) == '.')))  {
 1450     5       
 1451     5                           /* have the previous directory entry, remember that */
 1452     5                           have_entry = TRUE;
 1453     5                           /* and keep track of where the entry starts */
 1454     5                           new_offset = dir_offset;
 1455     5                           new_entry = cur_dir;
 1456     5                       }
 1457     4                       else  {
 1458     5       
 1459     5                           /* not a previous entry, ignore it and keep looking */
 1460     5                           ;
 1461     5                       }
 1462     4                   }
 1463     3               }
 1464     2           }
 1465     1       
 1466     1           /* if no error, update to the new sector, offset, and directory entry */
 1467     1           if (!error)  {
 1468     2       
 1469     2               /* first read in the new sector if had moved past it */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  27


 1470     2               if (new_offset != dir_offset)
 1471     2                   error = (get_disk_blocks(&dir_info, new_offset, 1,
 1472     2                                        (unsigned short int far *) dir_sector) != 1);
 1473     2               /* now update the sector offset and directory entry */
 1474     2               dir_offset = new_offset;
 1475     2               cur_dir = new_entry - 1;    /* get_next_dir_entry() will inc this */
 1476     2           }
 1477     1       
 1478     1       
 1479     1           /* if finished without an error then get the actual previous filename */
 1480     1           if (done & !error)  {
 1481     2       
 1482     2               /* get the entry watching for errors */
 1483     2               /* since we've backed up past the previous entry, this will now */
 1484     2               /*    find the previous entry */
 1485     2               error = get_next_dir_entry();
 1486     2           }
 1487     1       
 1488     1       
 1489     1           /* check if there was an error */
 1490     1           /*    note that this is redundant if error is from get_next_dir_entry() */
 1491     1           /*    but it's needed if error is from get_disk_blocks() */
 1492     1           if (error)  {
 1493     2               /* had an error - clear out the data */
 1494     2               /* clear the filename */
 1495     2               filename[0] = '\0';
 1496     2               /* set the file info to the first sector */
 1497     2               cur_info.sector    = first_file_sector;
 1498     2               cur_info.size      = sectors_per_cluster;
 1499     2               cur_info.next      = CHAIN_END;
 1500     2               cur_info.offset    = 0;
 1501     2               cur_info.cluster1  = 2;
 1502     2               cur_info.cache_idx = 0;
 1503     2           }
 1504     1       
 1505     1       
 1506     1           /* finally done, return with the error status */
 1507     1           return  error;
 1508     1       
 1509     1       }
 1510             
 1511             
 1512             
 1513             
 1514             /* local functions to support FAT16/FAT32 fragmented files */
 1515             
 1516             
 1517             /*
 1518                get_disk_blocks
 1519             
 1520                Description:      This function reads blocks from the file whose
 1521                                  information block is passed as the first argument.  The
 1522                                  data "read" is written to the memory pointed to by the
 1523                                  fourth argument.  The number of blocks requested is given
 1524                                  as the third argument.  The starting block number in the
 1525                                  file to read is passed as the second argument.  The
 1526                                  number of sectors (blocks) actually read is returned.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  28


 1527             
 1528                Arguments:        info (struct block_info *)      - block information to be
 1529                                                                    used and possibly
 1530                                                                    updated by this
 1531                                                                    function to get file
 1532                                                                    data.
 1533                                  block (unsigned long int)       - sector number (relative
 1534                                                                    to the start of the
 1535                                                                    file) at which to start
 1536                                                                    reading.
 1537                                  length (int)                    - number of blocks to be
 1538                                                                    read.
 1539                                  dest (unsigned short int far *) - pointer to the memory
 1540                                                                    where the read data is
 1541                                                                    to be written.
 1542                Return Value:     The number of blocks actually read.
 1543             
 1544                Input:            None.
 1545                Output:           None.
 1546             
 1547                Error Handling:   None.
 1548             
 1549                Algorithms:       None.
 1550                Data Structures:  None.
 1551             
 1552                Shared Variables: None.
 1553             
 1554                Author:           Glen George
 1555                Last Modified:    March 17, 2013
 1556             
 1557             */
 1558             
 1559             int  get_disk_blocks(struct block_info *info, unsigned long int block,
 1560                                  int length, unsigned short int far *dest)
 1561             {
 1562     1           /* variables */
 1563     1           int   sectors_read = 0;     /* total number of sectors actually read */
 1564     1       
 1565     1           int   xfer_cnt;             /* number of blocks to try to read */
 1566     1           int   blk_cnt;              /* number of blocks read by get_blocks */
 1567     1       
 1568     1           char  error = FALSE;        /* error reading the disk */
 1569     1       
 1570     1       
 1571     1       
 1572     1           /* read contiguous groups of blocks until error or all are read */
 1573     1           while (!error && (sectors_read < length))  {
 1574     2       
 1575     2               /* see if can get sectors from current file block */
 1576     2               if ((block < info->offset) || (block >= (info->offset + info->size)))
 1577     2                   /* the sector isn't in current block, get new block */
 1578     2                   get_block_info(info, block);
 1579     2       
 1580     2               /* should now be able to find/read the desired sectors */
 1581     2               /* see how many sectors are contiguous */
 1582     2               if ((info->offset + info->size - block) >= (length - sectors_read))
 1583     2                   /* all the sectors we need are contiguous in this block */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  29


 1584     2                   xfer_cnt = length - sectors_read;
 1585     2               else
 1586     2                   /* can only get contiguous sectors up to the end of the block */
 1587     2                   xfer_cnt = info->offset + info->size - block;
 1588     2       
 1589     2               /* now call the get_blocks function to actually read sectors */
 1590     2               blk_cnt = get_blocks(info->sector + block - info->offset, xfer_cnt, dest);
 1591     2       
 1592     2               /* update the state of the transfer */
 1593     2               block += blk_cnt;                   /* update next block to be read */
 1594     2               sectors_read += blk_cnt;            /* update total sectors read */
 1595     2               dest += blk_cnt * IDE_BLOCK_SIZE;   /* update buffer position */
 1596     2       
 1597     2               /* check for an error */
 1598     2               if (blk_cnt < xfer_cnt)
 1599     2                   /* couldn't read all the sectors so an error must have occurred */
 1600     2                   error = TRUE;
 1601     2           }
 1602     1       
 1603     1       
 1604     1           /* return the number of sectors actually read */
 1605     1           return  sectors_read;
 1606     1       
 1607     1       }
 1608             
 1609             
 1610             
 1611             
 1612             /*
 1613                get_block_info
 1614             
 1615                Description:      This function fills in the passed block information
 1616                                  structure with information from the FAT on the hard
 1617                                  drive.  The passed sector within the file along with the
 1618                                  current value of the block information are used to figure
 1619                                  out which block to load the structure with.  The cluster1
 1620                                  element of the structure is not changed.
 1621             
 1622                Arguments:        info (struct block_info *) - block information to be used
 1623                                                               and updated by this
 1624                                                               function.
 1625                                  sector (unsigned long int) - sector number within a file
 1626                                                               for which the block
 1627                                                               information is to be found.
 1628                Return Value:     None.
 1629             
 1630                Input:            None.
 1631                Output:           None.
 1632             
 1633                Error Handling:   None.
 1634             
 1635                Algorithms:       None.
 1636                Data Structures:  None.
 1637             
 1638                Shared Variables: FAT_cache - accessed to get block information.
 1639             
 1640                Author:           Glen George
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  30


 1641                Last Modified:    March 17, 2013
 1642             
 1643             */
 1644             
 1645             static  void  get_block_info(struct block_info *info, unsigned long int sector)
 1646             {
 1647     1           /* variables */
 1648     1           struct  cache_entry  e;                     /* information on clusters */
 1649     1       
 1650     1           char                 have_block = FALSE;    /* have the requested block */
 1651     1       
 1652     1       
 1653     1       
 1654     1           /* if don't have the block yet, check if the sector is in a later cache entry */
 1655     1           while (!have_block && (info->cache_idx != -1) &&
 1656     1                  ((info->cache_idx + 1) < (FAT_CACHE_SIZE / sizeof(struct cache_entry))) &&
 1657     1                  (info->next != CHAIN_END) &&
 1658     1                  (sector >= (info->offset + info->size)))  {
 1659     2       
 1660     2               /* move to the next FAT cache entry (they are in file order) */
 1661     2               info->offset += info->size;
 1662     2               info->cache_idx++;
 1663     2               info->sector = (FAT_cache[info->cache_idx].cluster - 2) * sectors_per_cluster +
 1664     2                              first_file_sector;
 1665     2               info->size = FAT_cache[info->cache_idx].size;
 1666     2               info->next = FAT_cache[info->cache_idx + 1].cluster;
 1667     2           }
 1668     1       
 1669     1           /* check if have the sector now */
 1670     1           if ((sector >= info->offset) && (sector < (info->offset + info->size)))
 1671     1               /* have the sector in this new block */
 1672     1               have_block = TRUE;
 1673     1       
 1674     1       
 1675     1           /* if don't have the block yet, check if the sector is in an earlier cache entry */
 1676     1           while (!have_block && (info->cache_idx > 0) &&
 1677     1                  (info->next != CHAIN_END) && (sector < info->offset))  {
 1678     2       
 1679     2               /* move to the previous FAT cache entry (they are in file order) */
 1680     2               info->cache_idx--;
 1681     2               info->offset -= FAT_cache[info->cache_idx].size;
 1682     2               info->sector = (FAT_cache[info->cache_idx].cluster - 2) * sectors_per_cluster +
 1683     2                              first_file_sector;
 1684     2               info->size = FAT_cache[info->cache_idx].size;
 1685     2               info->next = FAT_cache[info->cache_idx + 1].cluster;
 1686     2           }
 1687     1       
 1688     1           /* check if have the sector now */
 1689     1           if ((sector >= info->offset) && (sector < (info->offset + info->size)))
 1690     1               /* have the sector in this new block */
 1691     1               have_block = TRUE;
 1692     1       
 1693     1       
 1694     1           /* if still don't have the sector will need to search the FAT on the */
 1695     1           /*    hard drive for it - either start at beginning or next cluster */
 1696     1           if (!have_block)  {
 1697     2       
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  31


 1698     2               /* still don't have it, check where to start searching */
 1699     2               if (sector < info->offset)  {
 1700     3                   /* moving backward in file, have to start at beginning */
 1701     3                   info->next = info->cluster1;
 1702     3                   /* reset block information to zero sized block at beginning of file */
 1703     3                   info->size = 0;
 1704     3                   info->offset = 0;
 1705     3               }
 1706     2           }
 1707     1       
 1708     1           /* now search through the hard drive FAT for the sector */
 1709     1           while (!have_block && (info->next != CHAIN_END) &&
 1710     1                  (sector >= (info->offset + info->size)))  {
 1711     2       
 1712     2               /* get information on the contiguous sectors starting at current cluster */
 1713     2               info->next = get_contig_sectors(info->next, &e);
 1714     2       
 1715     2               /* now fill in the block information based on this */
 1716     2               /* watch for special case of FAT16 root directory */
 1717     2               if (info->cluster1 == 0)
 1718     2                   /* FAT16 root use FAT16 starting sector, not returned cluster */
 1719     2                   info->sector = root_start_sector;
 1720     2               else
 1721     2                   /* not FAT16 root, use returned cluster to get sector */
 1722     2                   info->sector = (e.cluster - 2) * sectors_per_cluster + first_file_sector;
 1723     2       
 1724     2               /* get the rest of the information */
 1725     2               info->offset += info->size;
 1726     2               info->size = e.size;
 1727     2       
 1728     2               /* getting information directly from hard drive so no cache index */
 1729     2               info->cache_idx = -1;
 1730     2           }
 1731     1       
 1732     1       
 1733     1           /* we've looked everywhere at this point so we'd better have the sector */
 1734     1           /* no way to report errors if we don't, so just return now */
 1735     1           return;
 1736     1       
 1737     1       }
 1738             
 1739             
 1740             
 1741             
 1742             /*
 1743                get_contig_sectors
 1744             
 1745                Description:      This function reads the FAT information on the hard drive
 1746                                  to fill in the passed structure with information for the
 1747                                  passed cluster.  The returned information gives the
 1748                                  number of contiguous sectors starting at the passed
 1749                                  cluster number.  The cluster number of the first
 1750                                  non-contiguous cluster is returned.
 1751             
 1752                Operation:        The function first checks for the special cases of
 1753                                  cluster 0 (FAT16 root directory) and END_CHAIN (returns
 1754                                  a zero length entry).  If it is neither special case the
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  32


 1755                                  first FAT on the hard drive is read for the passed
 1756                                  cluster number and the information for that entry is
 1757                                  entered in the structure.  The function continues reading
 1758                                  the FAT as long as the clusters are contiguous, updating
 1759                                  the size of the contiguous block as it goes.
 1760             
 1761                Arguments:        cluster (unsigned long int)  - starting cluster number 
 1762                                                                 at which the number of
 1763                                                                 contiguous sectors is to
 1764                                                                 be found.
 1765                                  entry (struct cache_entry *) - cache entry (general FAT)
 1766                                                                 information to be filled
 1767                                                                 in by this function.
 1768                Return Value:     (unsigned long int) - cluster number of the first
 1769                                  non-contiguous cluster following the passed cluster
 1770                                  number, CHAIN_END if the end of the file is reached
 1771                                  before a non-contiguous cluster is found.
 1772             
 1773                Input:            None.
 1774                Output:           None.
 1775             
 1776                Error Handling:   None.
 1777             
 1778                Algorithms:       None.
 1779                Data Structures:  None.
 1780             
 1781                Shared Variables: clusters_per_sector - accessed.
 1782                                  fat16               - accessed to determine FAT type.
 1783                                  first_FAT_sector    - accessed.
 1784                                  first_file_sector   - accessed.
 1785                                  root_dir_size       - accessed if cluster is FAT16 root.
 1786                                  root_start_sector   - accessed if cluster is FAT16 root.
 1787                                  sectors_per_cluster - accessed.
 1788             
 1789                Author:           Glen George
 1790                Last Modified:    March 17, 2013
 1791             
 1792             */
 1793             
 1794             static  unsigned long int  get_contig_sectors(unsigned long int cluster,
 1795                                                           struct cache_entry *entry)
 1796             {
 1797     1           /* variables */
 1798     1           unsigned long int   s;                      /* sector number of FAT entry */
 1799     1           unsigned long int   c;                      /* cluster offset of FAT entry */
 1800     1       
 1801     1           unsigned long int   next;                   /* next cluster from FAT */
 1802     1       
 1803     1           unsigned short int  sector[IDE_BLOCK_SIZE]; /* sector from the hard drive */
 1804     1       
 1805     1           char                contig = TRUE;          /* clusters are contiguous */
 1806     1           char                error = FALSE;          /* error flag */
 1807     1       
 1808     1       
 1809     1       
 1810     1           /* first check for special cluster values */
 1811     1           if (cluster == 0)  {
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  33


 1812     2       
 1813     2               /* zero cluster is illegal, so this indicates want FAT16 root */
 1814     2               entry->cluster = root_start_sector;     /* use root values */
 1815     2               entry->size = root_dir_size;
 1816     2               next = CHAIN_END;                       /* no next cluster */
 1817     2           }
 1818     1           else if (cluster == CHAIN_END)  {
 1819     2       
 1820     2               /* end of chain indicator, return a zero length cluster */
 1821     2               entry->cluster = 0;
 1822     2               entry->size = 0;
 1823     2               next = CHAIN_END;                       /* no next cluster */
 1824     2           }
 1825     1           else  {
 1826     2       
 1827     2               /* normal cluster number */
 1828     2               /* first sector for entry is based on cluster number */
 1829     2               entry->cluster = cluster;
 1830     2               /* nothing in it yet */
 1831     2               entry->size = 0;
 1832     2       
 1833     2               /* now try to get info from FAT */
 1834     2               /* first get sector number for the cluster entry */
 1835     2               s = cluster / clusters_per_sector + first_FAT_sector;
 1836     2               /* get cluster entry within the sector */
 1837     2               c = cluster % clusters_per_sector;
 1838     2               /* and read the sector from the hard drive */
 1839     2               error = (get_blocks(s, 1, (unsigned short int far *) sector) != 1);
 1840     2       
 1841     2               /* while there are contiguous clusters, get the FAT information */
 1842     2               while (contig && !error)  {
 1843     3       
 1844     3                   /* check if cluster number is still in this sector */
 1845     3                   if (c >= clusters_per_sector)  {
 1846     4                       /* finished entries in this sector, move to next */
 1847     4                       s++;
 1848     4                       /* at the start of this sector */
 1849     4                       c = 0;
 1850     4                       /* and read the sector from the hard drive */
 1851     4                       error = (get_blocks(s, 1, (unsigned short int far *) sector) != 1);
 1852     4                   }
 1853     3       
 1854     3                   /* get the next cluster number (based on FAT type) */
 1855     3                   if (fat16)
 1856     3                       /* FAT16 so each entry is one word */
 1857     3                       next = sector[c];
 1858     3                   else
 1859     3                       /* FAT32, each entry is two words */
 1860     3                       next = ((unsigned long int *) sector)[c];
 1861     3       
 1862     3                   /* check if the cluster contiguous */
 1863     3                   /* note that end of chain markers will not be contiguous */
 1864     3                   contig = (next == (cluster + 1));
 1865     3       
 1866     3                   /* this cluster was already found to be contiguous, so update size */
 1867     3                   entry->size += sectors_per_cluster;
 1868     3       
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  34


 1869     3                   /* can update the cluster number assuming contiguous */
 1870     3                   cluster++;
 1871     3                   /* and move to next cluster in this FAT sector */
 1872     3                   c++;
 1873     3               }
 1874     2       
 1875     2               /* set the next cluster pointer in chain to CHAIN_END if there was */
 1876     2               /* an error or hit the end of the cluster chain in the FAT */
 1877     2               if (error || (fat16 && (next >= FAT16_BAD)) ||
 1878     2                   (!fat16 && (next >= FAT32_BAD)))  {
 1879     3                   /* have an error or a bad cluster or end of chain marker */
 1880     3                   /* next pointer is end of chain */
 1881     3                   next = CHAIN_END;
 1882     3               }
 1883     2           }
 1884     1       
 1885     1       
 1886     1           /* done getting the cluster information, return */
 1887     1           return  next;
 1888     1       
 1889     1       }
 1890             
 1891             
 1892             
 1893             
 1894             /* locally global variables for the stack routines */
 1895             
 1896             /* stack of directory information */
 1897             static  char               dirnames[MAX_PATH_CHARS];            /* names */
 1898             static  unsigned long int  dirclusterstack[MAX_NUM_SUBDIRS];    /* starting clusters */
 1899             static  int                dirnamestack[MAX_NUM_SUBDIRS];       /* name positions in dirnames */
 1900             static  int                dirstack_ptr;                        /* the stack pointer */
 1901             
 1902             
 1903             
 1904             
 1905             /*
 1906                init_dir_stack
 1907             
 1908                Description:      This function initializes the directory stack.  It clears
 1909                                  the directory names, zeros the first stack elements, and
 1910                                  initializes the stack pointer.
 1911             
 1912                Arguments:        None.
 1913                Return Value:     None.
 1914             
 1915                Input:            None.
 1916                Output:           None.
 1917             
 1918                Error Handling:   None.
 1919             
 1920                Algorithms:       None.
 1921                Data Structures:  None.
 1922             
 1923                Shared Variables: dirclusterstack - first element is set to 0.
 1924                                  dirnames        - first character is set to '\0'.
 1925                                  dirnamestack    - first element is set to 0.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  35


 1926                                  dirstack_ptr    - initialized to -1.
 1927             
 1928                Author:           Glen George
 1929                Last Modified:    March 17, 2013
 1930             
 1931             */
 1932             
 1933             static  void  init_dir_stack()
 1934             {
 1935     1           /* variables */
 1936     1             /* none */
 1937     1       
 1938     1       
 1939     1       
 1940     1           /* set the string of names to the empty string */
 1941     1           dirnames[0] = '\0';
 1942     1       
 1943     1           /* initialize the first directory entries to 0 */
 1944     1           dirclusterstack[0] = 0;
 1945     1           dirnamestack[0] = 0;
 1946     1       
 1947     1           /* finally, set the stack pointer to empty stack */
 1948     1           dirstack_ptr = -1;
 1949     1       
 1950     1       
 1951     1           /* all done with the initialization - return */
 1952     1           return;
 1953     1       
 1954     1       }
 1955             
 1956             
 1957             
 1958             
 1959             /*
 1960                new_directory
 1961             
 1962                Description:      This function handles a new directory.  It may be either
 1963                                  a subdirectory or a parent directory.  If a subdirectory
 1964                                  the directory information (name and starting sector) is
 1965                                  added to the directory stack.  If a parent directory, it
 1966                                  is removed from the directory stack.  It is assumed that
 1967                                  the directory in question is the current entry.
 1968             
 1969                Arguments:        None.
 1970                Return Value:     None.
 1971             
 1972                Input:            None.
 1973                Output:           None.
 1974             
 1975                Error Handling:   None.
 1976             
 1977                Algorithms:       None.
 1978                Data Structures:  None.
 1979             
 1980                Shared Variables: cur_info        - accessed to check if the top of the
 1981                                                    stack matches the current
 1982                                                    file/directory.
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  36


 1983                                  dir_info        - accessed for the directory starting
 1984                                                    cluster number.
 1985                                  dirclusterstack - may be updated to add a directory
 1986                                                    starting cluster location.
 1987                                  dirname         - accessed to get the current directory
 1988                                                    name.
 1989                                  dirnames        - updated to add or remove directory
 1990                                                    names.
 1991                                  dirnamestack    - may be updated to add the starting
 1992                                                    character number in dirnames[] for this
 1993                                                    directory name.
 1994                                  dirstack_ptr    - updated to adjust the stack.
 1995             
 1996                Author:           Glen George
 1997                Last Modified:    March 17, 2013
 1998             
 1999             */
 2000             
 2001             static  void  new_directory()
 2002             {
 2003     1           /* variables */
 2004     1             /* none */
 2005     1       
 2006     1       
 2007     1       
 2008     1           /* check if the current entry matches the top of the stack */
 2009     1           if ((dirstack_ptr >= 0) && (dirclusterstack[dirstack_ptr] == cur_info.cluster1))  {
 2010     2       
 2011     2               /* new directory is on stack - need to pop it off of the stack */
 2012     2               /* first get rid of the name */
 2013     2               dirnames[dirnamestack[dirstack_ptr]] = '\0';
 2014     2               /* now just decrement the stack pointer */
 2015     2               dirstack_ptr--;
 2016     2           }
 2017     1           else  {
 2018     2       
 2019     2               /* does not match top of the stack, need to push new value */
 2020     2               /* note - push the info for the current directory, not entry */
 2021     2               /* make sure not out of space */
 2022     2               if ((dirstack_ptr < (MAX_NUM_SUBDIRS - 1)) &&
 2023     2                   ((strlen(dirnames) + strlen(dirname)) < MAX_PATH_CHARS))  {
 2024     3       
 2025     3                   /* there is room - update the stack pointer */
 2026     3                   dirstack_ptr++;
 2027     3                   /* save the starting cluster */
 2028     3                   dirclusterstack[dirstack_ptr] = dir_info.cluster1;
 2029     3                   /* save the name pointer and the name */
 2030     3                   dirnamestack[dirstack_ptr] = strlen(dirnames);
 2031     3                   strcat(dirnames, dirname);
 2032     3               }
 2033     2               else  {
 2034     3       
 2035     3                   /* out of room in the stack - this shouldn't happen */
 2036     3                   ;
 2037     3               }
 2038     2           }
 2039     1       
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  37


 2040     1       
 2041     1           /* all done - return */
 2042     1           return;
 2043     1       
 2044     1       }
 2045             
 2046             
 2047             
 2048             
 2049             /*
 2050                get_dir_tos_name
 2051             
 2052                Description:      This function returns the name of the directory on the
 2053                                  top of the directory stack.  If the stack is empty, the
 2054                                  empty string is returned.
 2055             
 2056                Arguments:        None.
 2057                Return Value:     (const char *) - pointer to the name of the directory on
 2058                                  the top of the directory stack or the pointer to an empty
 2059                                  string if there is nothing on the stack.
 2060             
 2061                Input:            None.
 2062                Output:           None.
 2063             
 2064                Error Handling:   If nothing is on the stack an empty string is returned.
 2065             
 2066                Algorithms:       None.
 2067                Data Structures:  None.
 2068             
 2069                Shared Variables: dirnames     - accessed to get the directory name.
 2070                                  dirnamestack - accessed to find position of name.
 2071                                  dirstack_ptr - accessed to find stack entry.
 2072             
 2073                Author:           Glen George
 2074                Last Modified:    June 27, 2002
 2075             
 2076             */
 2077             
 2078             static  const char  *get_dir_tos_name()
 2079             {
 2080     1           /* variables */
 2081     1           const char  *name;
 2082     1       
 2083     1       
 2084     1       
 2085     1           /* check if there is something in the directory stack */
 2086     1           if (dirstack_ptr >= 0)  {
 2087     2       
 2088     2               /* there is something on the stack, get the pointer to the name */
 2089     2               name = &(dirnames[dirnamestack[dirstack_ptr]]);
 2090     2           }
 2091     1           else  {
 2092     2       
 2093     2               /* nothing on the stack */
 2094     2               /* make sure the directory names list is empty */
 2095     2               dirnames[0] = '\0';
 2096     2               /* and return a pointer to that empty string */
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  38


 2097     2               name = dirnames;
 2098     2           }
 2099     1       
 2100     1       
 2101     1           /* all done - return with the name pointer */
 2102     1           return  name;
 2103     1       
 2104     1       }
 2105             
 2106             
 2107             
 2108             
 2109             /*
 2110                get_dir_tos_cluster
 2111             
 2112                Description:      This function returns the starting cluster number of the
 2113                                  directory on the top of the directory stack.  If the
 2114                                  stack is empty, zero (0) is returned.
 2115             
 2116                Arguments:        None.
 2117                Return Value:     (unsigned long int) - the starting cluster of the
 2118                                  directory on the top of the directory stack or zero (0)
 2119                                  if there is nothing on the stack.
 2120             
 2121                Input:            None.
 2122                Output:           None.
 2123             
 2124                Error Handling:   If nothing is on the stack, zero (0) is returned.
 2125             
 2126                Algorithms:       None.
 2127                Data Structures:  None.
 2128             
 2129                Shared Variables: dirclusterstack - accessed to get cluster number.
 2130                                  dirstack_ptr    - accessed to get cluster number.
 2131             
 2132                Author:           Glen George
 2133                Last Modified:    March 17, 2013
 2134             
 2135             */
 2136             
 2137             static  unsigned long int  get_dir_tos_sector()
 2138             {
 2139     1           /* variables */
 2140     1           unsigned long int  c;       /* cluster number to return */
 2141     1       
 2142     1       
 2143     1       
 2144     1           /* check if there is something in the directory stack */
 2145     1           if (dirstack_ptr >= 0)  {
 2146     2       
 2147     2               /* there is something on the stack, return the cluster number */
 2148     2               c = dirclusterstack[dirstack_ptr];
 2149     2           }
 2150     1           else  {
 2151     2       
 2152     2               /* nothing on the stack, return 0 */
 2153     2               c = 0;
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  39


 2154     2           }
 2155     1       
 2156     1       
 2157     1           /* all done - return with the starting cluster number */
 2158     1           return  c;
 2159     1       
 2160     1       }
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  40
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 240
                           init_FAT_system      PROC NEAR
             0000  56              PUSH    SI
             0001  57              PUSH    DI
             0002  C8080200        ENTER   208H,0H
                           @1:
                                                   ; STATEMENT # 262
             0006  B80000          MOV     AX,0H
             0009  BA0050          MOV     DX,5000H
             000C  89064C02        MOV     FAT_cache,AX
             0010  89164E02        MOV     FAT_cache+2H,DX
                                                   ; STATEMENT # 267
             0014  8D8600FE        LEA     AX,[BP].s
             0018  1E              PUSH    DS      ; 1
             0019  50              PUSH    AX      ; 2
             001A  680100          PUSH    1H
             001D  680000          PUSH    0H
             0020  680000          PUSH    0H
             0023  E80000          CALL    get_blocks
             0026  81C40A00        ADD     SP,0AH
             002A  81F80100        CMP     AX,1H
             002E  B80100          MOV     AX,1H
             0031  7501            JNZ     $+3H
             0033  48              DEC     AX
             0034  8886F9FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 271
             0038  8B4EC6          MOV     CX,[BP].s+1C6H
             003B  BA0000          MOV     DX,0H
             003E  81E1FFFF        AND     CX,0FFFFH
             0042  81E20000        AND     DX,0H
             0046  8B5EC8          MOV     BX,[BP].s+1C8H
             0049  BF0000          MOV     DI,0H
             004C  81E3FFFF        AND     BX,0FFFFH
             0050  81E70000        AND     DI,0H
             0054  51              PUSH    CX      ; 1
             0055  B91000          MOV     CX,10H
             0058  D1E3            SHL     BX,1
             005A  D1D7            RCL     DI,1
             005C  E2FA            LOOP    $-4H
             005E  59              POP     CX      ; 1
             005F  03D9            ADD     BX,CX
             0061  13FA            ADC     DI,DX
             0063  891E3802        MOV     partition_start,BX
             0067  893E3A02        MOV     partition_start+2H,DI
                                                   ; STATEMENT # 274
             006B  8B4EC2          MOV     CX,[BP].s+1C2H
             006E  81E1FF00        AND     CX,0FFH
             0072  81F90600        CMP     CX,6H
             0076  B90100          MOV     CX,1H
             0079  7401            JZ      $+3H
             007B  49              DEC     CX
             007C  880ED607        MOV     fat16,CL
                                                   ; STATEMENT # 279
             0080  0AC0            OR      AL,AL
             0082  7403            JZ      $+5H
             0084  E92900          JMP     @2
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  41
                  ASSEMBLY LISTING OF OBJECT CODE


             0087  8D8600FE        LEA     AX,[BP].s
             008B  1E              PUSH    DS      ; 1
             008C  50              PUSH    AX      ; 2
             008D  680100          PUSH    1H
             0090  FF363A02        PUSH    partition_start+2H; 4
             0094  FF363802        PUSH    partition_start; 5
             0098  E80000          CALL    get_blocks
             009B  81C40A00        ADD     SP,0AH
             009F  81F80100        CMP     AX,1H
             00A3  B80100          MOV     AX,1H
             00A6  7501            JNZ     $+3H
             00A8  48              DEC     AX
             00A9  0BC0            OR      AX,AX
             00AB  7503            JNZ     $+5H
             00AD  E90600          JMP     @157
                           @2:
             00B0  B80100          MOV     AX,1H
             00B3  E90200          JMP     @156
                           @157:
             00B6  2BC0            SUB     AX,AX
                           @156:
             00B8  8886F9FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 285
             00BC  8B860EFE        MOV     AX,[BP].s+0EH
             00C0  99              CWD
             00C1  8B3E3A02        MOV     DI,partition_start+2H
             00C5  8B0E3802        MOV     CX,partition_start
             00C9  03C8            ADD     CX,AX
             00CB  13FA            ADC     DI,DX
             00CD  890E3C02        MOV     first_FAT_sector,CX
             00D1  893E3E02        MOV     first_FAT_sector+2H,DI
                                                   ; STATEMENT # 287
             00D5  8A9E0DFE        MOV     BL,[BP].s+0DH
             00D9  B700            MOV     BH,0H
             00DB  BE0000          MOV     SI,0H
             00DE  891E3202        MOV     sectors_per_cluster,BX
             00E2  89363402        MOV     sectors_per_cluster+2H,SI
                                                   ; STATEMENT # 291
             00E6  823ED60700      CMP     fat16,0H
             00EB  7503            JNZ     $+5H
             00ED  E95600          JMP     @3
                                                   ; STATEMENT # 295
             00F0  8A8610FE        MOV     AL,[BP].s+10H
             00F4  B400            MOV     AH,0H
             00F6  F7AE16FE        IMUL    [BP].s+16H
             00FA  99              CWD
             00FB  03C8            ADD     CX,AX
             00FD  13FA            ADC     DI,DX
             00FF  890E4402        MOV     root_start_sector,CX
             0103  893E4602        MOV     root_start_sector+2H,DI
                                                   ; STATEMENT # 297
             0107  8B8611FE        MOV     AX,[BP].s+11H
             010B  BB1000          MOV     BX,10H
             010E  99              CWD
             010F  F7FB            IDIV    BX
             0111  99              CWD
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  42
                  ASSEMBLY LISTING OF OBJECT CODE


             0112  89064802        MOV     root_dir_size,AX
             0116  89164A02        MOV     root_dir_size+2H,DX
                                                   ; STATEMENT # 300
             011A  03C8            ADD     CX,AX
             011C  13FA            ADC     DI,DX
             011E  890E4002        MOV     first_file_sector,CX
             0122  893E4202        MOV     first_file_sector+2H,DI
                                                   ; STATEMENT # 303
             0126  8D862BFE        LEA     AX,[BP].s+2BH
             012A  8986FCFD        MOV     [BP].vid,AX
             012E  8C9EFEFD        MOV     [BP].vid+2H,DS
                                                   ; STATEMENT # 306
             0132  C70636020001    MOV     clusters_per_sector,100H
                                                   ; STATEMENT # 309
             0138  B80000          MOV     AX,0H
             013B  89062C02        MOV     cur_info+10H,AX
             013F  89062E02        MOV     cur_info+12H,AX
                                                   ; STATEMENT # 311
             0143  E96C00          JMP     @4
                           @3:
                                                   ; STATEMENT # 314
             0146  B80000          MOV     AX,0H
             0149  89064402        MOV     root_start_sector,AX
             014D  89064602        MOV     root_start_sector+2H,AX
                                                   ; STATEMENT # 315
             0151  89064802        MOV     root_dir_size,AX
             0155  89064A02        MOV     root_dir_size+2H,AX
                                                   ; STATEMENT # 319
             0159  8B860EFE        MOV     AX,[BP].s+0EH
             015D  99              CWD
             015E  03063802        ADD     AX,partition_start
             0162  13163A02        ADC     DX,partition_start+2H
             0166  50              PUSH    AX      ; 1
             0167  8A8610FE        MOV     AL,[BP].s+10H
             016B  B400            MOV     AH,0H
             016D  BF0000          MOV     DI,0H
             0170  8BB626FE        MOV     SI,[BP].s+26H
             0174  8B8E24FE        MOV     CX,[BP].s+24H
             0178  52              PUSH    DX      ; 2
             0179  8BD7            MOV     DX,DI
             017B  8BFE            MOV     DI,SI
             017D  9A00000000      CALL    LQ_SLONG_MUL
             0182  5F              POP     DI      ; 2
             0183  59              POP     CX      ; 1
             0184  03C1            ADD     AX,CX
             0186  13D7            ADC     DX,DI
             0188  89064002        MOV     first_file_sector,AX
             018C  89164202        MOV     first_file_sector+2H,DX
                                                   ; STATEMENT # 322
             0190  8D8647FE        LEA     AX,[BP].s+47H
             0194  8986FCFD        MOV     [BP].vid,AX
             0198  8C9EFEFD        MOV     [BP].vid+2H,DS
                                                   ; STATEMENT # 325
             019C  C70636028000    MOV     clusters_per_sector,80H
                                                   ; STATEMENT # 328
             01A2  8B962EFE        MOV     DX,[BP].s+2EH
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  43
                  ASSEMBLY LISTING OF OBJECT CODE


             01A6  8B862CFE        MOV     AX,[BP].s+2CH
             01AA  89062C02        MOV     cur_info+10H,AX
             01AE  89162E02        MOV     cur_info+12H,DX
                                                   ; STATEMENT # 329
                           @4:
                                                   ; STATEMENT # 333
             01B2  C7063002FFFF    MOV     cur_info+14H,0FFFFH
                                                   ; STATEMENT # 335
             01B8  B8FFFF          MOV     AX,0FFFFH
             01BB  89062802        MOV     cur_info+0CH,AX
             01BF  89062A02        MOV     cur_info+0EH,AX
                                                   ; STATEMENT # 337
             01C3  680000          PUSH    0H
             01C6  680000          PUSH    0H
             01C9  B81C02          MOV     AX,OFFSET(cur_info)
             01CC  1E              PUSH    DS      ; 3
             01CD  50              PUSH    AX      ; 4
             01CE  E88F0D          CALL    get_block_info
             01D1  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 341
             01D5  C786FAFD0000    MOV     [BP].i,0H
             01DB  E90400          JMP     @7
                           @5:
             01DE  FF86FAFD        INC     [BP].i
                           @7:
             01E2  8B9EFAFD        MOV     BX,[BP].i
             01E6  81FB0B00        CMP     BX,0BH
             01EA  7C03            JL      $+5H
             01EC  E90E00          JMP     @6
                                                   ; STATEMENT # 342
             01EF  C4B6FCFD        LES     SI,[BP].vid
             01F3  268A00          MOV     AL,ES:[BX].[SI]
             01F6  8887D605        MOV     dirname[BX],AL
             01FA  E9E1FF          JMP     @5
                           @6:
                                                   ; STATEMENT # 344
             01FD  C606E10500      MOV     dirname+0BH,0H
                                                   ; STATEMENT # 346
             0202  C606D60600      MOV     filename,0H
                                                   ; STATEMENT # 350
             0207  F686F9FDFF      TEST    [BP].error,0FFH
             020C  7403            JZ      $+5H
             020E  E91300          JMP     @8
             0211  81BE0BFE0002    CMP     [BP].s+0BH,200H
             0217  B80100          MOV     AX,1H
             021A  7501            JNZ     $+3H
             021C  48              DEC     AX
             021D  0BC0            OR      AX,AX
             021F  7503            JNZ     $+5H
             0221  E90600          JMP     @159
                           @8:
             0224  B80100          MOV     AX,1H
             0227  E90200          JMP     @158
                           @159:
             022A  2BC0            SUB     AX,AX
                           @158:
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  44
                  ASSEMBLY LISTING OF OBJECT CODE


             022C  8886F9FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 354
             0230  08C0            OR      AL,AL
             0232  7503            JNZ     $+5H
             0234  E92400          JMP     @9
                                                   ; STATEMENT # 357
             0237  C70640020100    MOV     first_file_sector,1H
             023D  C70642020000    MOV     first_file_sector+2H,0H
                                                   ; STATEMENT # 358
             0243  C7063C020100    MOV     first_FAT_sector,1H
             0249  C7063E020000    MOV     first_FAT_sector+2H,0H
                                                   ; STATEMENT # 359
             024F  C70632024000    MOV     sectors_per_cluster,40H
             0255  C70634020000    MOV     sectors_per_cluster+2H,0H
                                                   ; STATEMENT # 364
                           @9:
             025B  E8AE12          CALL    init_dir_stack
                                                   ; STATEMENT # 368
             025E  8A86F9FD        MOV     AL,[BP].error
             0262  C9              LEAVE
             0263  5F              POP     DI
             0264  5E              POP     SI
             0265  C3              RET
                                                   ; STATEMENT # 370
                           init_FAT_system      ENDP
                                                   ; STATEMENT # 401
                           get_partition_start      PROC NEAR
             0266  56              PUSH    SI
             0267  57              PUSH    DI
             0268  55              PUSH    BP
             0269  8BEC            MOV     BP,SP
                           @10:
                                                   ; STATEMENT # 408
             026B  8B163A02        MOV     DX,partition_start+2H
             026F  8B063802        MOV     AX,partition_start
             0273  5D              POP     BP
             0274  5F              POP     DI
             0275  5E              POP     SI
             0276  C3              RET
                                                   ; STATEMENT # 410
                           get_partition_start      ENDP
                                                   ; STATEMENT # 444
                           get_cur_file_name      PROC NEAR
             0278  56              PUSH    SI
             0279  57              PUSH    DI
             027A  55              PUSH    BP
             027B  8BEC            MOV     BP,SP
                           @11:
                                                   ; STATEMENT # 451
             027D  B8D606          MOV     AX,OFFSET(filename)
             0280  8CDA            MOV     DX,DS
             0282  5D              POP     BP
             0283  5F              POP     DI
             0284  5E              POP     SI
             0285  C3              RET
                                                   ; STATEMENT # 453
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  45
                  ASSEMBLY LISTING OF OBJECT CODE


                           get_cur_file_name      ENDP
                                                   ; STATEMENT # 486
                           get_cur_file_attr      PROC NEAR
             0286  56              PUSH    SI
             0287  57              PUSH    DI
             0288  55              PUSH    BP
             0289  8BEC            MOV     BP,SP
                           @12:
                                                   ; STATEMENT # 493
             028B  6B1E000220      IMUL    BX,cur_dir,20H
             0290  8A870B00        MOV     AL,dir_sector[BX+0BH]
             0294  5D              POP     BP
             0295  5F              POP     DI
             0296  5E              POP     SI
             0297  C3              RET
                                                   ; STATEMENT # 495
                           get_cur_file_attr      ENDP
                                                   ; STATEMENT # 527
                           cur_isDir      PROC NEAR
             0298  56              PUSH    SI
             0299  57              PUSH    DI
             029A  55              PUSH    BP
             029B  8BEC            MOV     BP,SP
                           @13:
                                                   ; STATEMENT # 534
             029D  E8E6FF          CALL    get_cur_file_attr
             02A0  B400            MOV     AH,0H
             02A2  F7C01000        TEST    AX,10H
             02A6  B80100          MOV     AX,1H
             02A9  7501            JNZ     $+3H
             02AB  48              DEC     AX
             02AC  B400            MOV     AH,0H
             02AE  5D              POP     BP
             02AF  5F              POP     DI
             02B0  5E              POP     SI
             02B1  C3              RET
                                                   ; STATEMENT # 536
                           cur_isDir      ENDP
                                                   ; STATEMENT # 568
                           cur_isParentDir      PROC NEAR
             02B2  56              PUSH    SI
             02B3  57              PUSH    DI
             02B4  55              PUSH    BP
             02B5  8BEC            MOV     BP,SP
                           @14:
                                                   ; STATEMENT # 576
             02B7  E8DEFF          CALL    cur_isDir
             02BA  0AC0            OR      AL,AL
             02BC  7503            JNZ     $+5H
             02BE  E92100          JMP     @15
             02C1  6B1E000220      IMUL    BX,cur_dir,20H
             02C6  8A870000        MOV     AL,dir_sector[BX]
             02CA  98              CBW
             02CB  81F82E00        CMP     AX,2EH
             02CF  B80100          MOV     AX,1H
             02D2  7401            JZ      $+3H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  46
                  ASSEMBLY LISTING OF OBJECT CODE


             02D4  48              DEC     AX
             02D5  0BC0            OR      AX,AX
             02D7  7503            JNZ     $+5H
             02D9  E90600          JMP     @15
             02DC  B80100          MOV     AX,1H
             02DF  E90200          JMP     @160
                           @15:
             02E2  2BC0            SUB     AX,AX
                           @160:
             02E4  5D              POP     BP
             02E5  5F              POP     DI
             02E6  5E              POP     SI
             02E7  C3              RET
                                                   ; STATEMENT # 578
                           cur_isParentDir      ENDP
                                                   ; STATEMENT # 611
                           get_cur_file_time      PROC NEAR
             02E8  56              PUSH    SI
             02E9  57              PUSH    DI
             02EA  C8020000        ENTER   2H,0H
                           @16:
                                                   ; STATEMENT # 618
             02EE  6B1E000220      IMUL    BX,cur_dir,20H
             02F3  8B871600        MOV     AX,dir_sector[BX+16H]
             02F7  50              PUSH    AX      ; 1
             02F8  81E01F00        AND     AX,1FH
             02FC  D1E0            SHL     AX,1
             02FE  8946FE          MOV     [BP].t,AX
                                                   ; STATEMENT # 620
             0301  5B              POP     BX      ; 1
             0302  53              PUSH    BX      ; 1
             0303  C1EB05          SHR     BX,5H
             0306  81E33F00        AND     BX,3FH
             030A  6BDB3C          IMUL    BX,BX,3CH
             030D  03D8            ADD     BX,AX
             030F  895EFE          MOV     [BP].t,BX
                                                   ; STATEMENT # 621
             0312  58              POP     AX      ; 1
             0313  C1E80B          SHR     AX,0BH
             0316  81E01F00        AND     AX,1FH
             031A  69C0100E        IMUL    AX,AX,0E10H
             031E  03C3            ADD     AX,BX
             0320  8946FE          MOV     [BP].t,AX
                                                   ; STATEMENT # 625
             0323  C9              LEAVE
             0324  5F              POP     DI
             0325  5E              POP     SI
             0326  C3              RET
                                                   ; STATEMENT # 627
                           get_cur_file_time      ENDP
                                                   ; STATEMENT # 660
                           get_cur_file_size      PROC NEAR
             0328  56              PUSH    SI
             0329  57              PUSH    DI
             032A  55              PUSH    BP
             032B  8BEC            MOV     BP,SP
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  47
                  ASSEMBLY LISTING OF OBJECT CODE


                           @17:
                                                   ; STATEMENT # 667
             032D  6B1E000220      IMUL    BX,cur_dir,20H
             0332  8B971E00        MOV     DX,dir_sector[BX+1EH]
             0336  8B871C00        MOV     AX,dir_sector[BX+1CH]
             033A  5D              POP     BP
             033B  5F              POP     DI
             033C  5E              POP     SI
             033D  C3              RET
                                                   ; STATEMENT # 669
                           get_cur_file_size      ENDP
                                                   ; STATEMENT # 703
                           get_cur_file_sector      PROC NEAR
             033E  56              PUSH    SI
             033F  57              PUSH    DI
             0340  55              PUSH    BP
             0341  8BEC            MOV     BP,SP
                           @18:
                                                   ; STATEMENT # 711
             0343  813E2E020000    CMP     cur_info+12H,0H
             0349  7506            JNZ     $+8H
             034B  813E2C020000    CMP     cur_info+10H,0H
             0351  7403            JZ      $+5H
             0353  E90C00          JMP     @19
                                                   ; STATEMENT # 713
             0356  8B164602        MOV     DX,root_start_sector+2H
             035A  8B064402        MOV     AX,root_start_sector
             035E  5D              POP     BP
             035F  5F              POP     DI
             0360  5E              POP     SI
             0361  C3              RET
                                                   ; STATEMENT # 714
                           @19:
                                                   ; STATEMENT # 716
             0362  8B162E02        MOV     DX,cur_info+12H
             0366  8B062C02        MOV     AX,cur_info+10H
             036A  81E80200        SUB     AX,2H
             036E  81DA0000        SBB     DX,0H
             0372  8B3E3402        MOV     DI,sectors_per_cluster+2H
             0376  8B0E3202        MOV     CX,sectors_per_cluster
             037A  9A00000000      CALL    LQ_ULONG_MUL
             037F  03064002        ADD     AX,first_file_sector
             0383  13164202        ADC     DX,first_file_sector+2H
             0387  5D              POP     BP
             0388  5F              POP     DI
             0389  5E              POP     SI
             038A  C3              RET
                                                   ; STATEMENT # 718
                           get_cur_file_sector      ENDP
                                                   ; STATEMENT # 750
                           get_ID3_tag      PROC NEAR
             038C  56              PUSH    SI
             038D  57              PUSH    DI
             038E  C8080200        ENTER   208H,0H
                           @20:
                                                   ; STATEMENT # 765
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  48
                  ASSEMBLY LISTING OF OBJECT CODE


             0392  E893FF          CALL    get_cur_file_size
             0395  81E88000        SUB     AX,80H
             0399  81DA0000        SBB     DX,0H
             039D  B90002          MOV     CX,200H
             03A0  BF0000          MOV     DI,0H
             03A3  9A00000000      CALL    LQ_SLONG_DIV
             03A8  8946FE          MOV     [BP].sector,AX
                                                   ; STATEMENT # 766
             03AB  E87AFF          CALL    get_cur_file_size
             03AE  81E88000        SUB     AX,80H
             03B2  81DA0000        SBB     DX,0H
             03B6  B90002          MOV     CX,200H
             03B9  BF0000          MOV     DI,0H
             03BC  9A00000000      CALL    LQ_SLONG_DIV
             03C1  897EFC          MOV     [BP].offset,DI
                                                   ; STATEMENT # 770
             03C4  8D86FAFD        LEA     AX,[BP].s
             03C8  1E              PUSH    DS      ; 1
             03C9  50              PUSH    AX      ; 2
             03CA  680100          PUSH    1H
             03CD  8B46FE          MOV     AX,[BP].sector
             03D0  99              CWD
             03D1  52              PUSH    DX      ; 4
             03D2  50              PUSH    AX      ; 5
             03D3  E8AE00          CALL    get_file_blocks
             03D6  81C40A00        ADD     SP,0AH
             03DA  81F80100        CMP     AX,1H
             03DE  B80100          MOV     AX,1H
             03E1  7501            JNZ     $+3H
             03E3  48              DEC     AX
             03E4  8886F9FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 773
             03E8  C746FA0000      MOV     [BP].i,0H
             03ED  E90600          JMP     @23
                           @21:
             03F0  FF46FA          INC     [BP].i
             03F3  FF46FC          INC     [BP].offset
                           @23:
             03F6  82BEF9FD00      CMP     [BP].error,0H
             03FB  7403            JZ      $+5H
             03FD  E95400          JMP     @22
             0400  817EFA8000      CMP     [BP].i,80H
             0405  7C03            JL      $+5H
             0407  E94A00          JMP     @22
                                                   ; STATEMENT # 776
             040A  817EFC0002      CMP     [BP].offset,200H
             040F  7D03            JGE     $+5H
             0411  E92D00          JMP     @24
                                                   ; STATEMENT # 778
             0414  8D86FAFD        LEA     AX,[BP].s
             0418  1E              PUSH    DS      ; 1
             0419  50              PUSH    AX      ; 2
             041A  680100          PUSH    1H
             041D  8B46FE          MOV     AX,[BP].sector
             0420  40              INC     AX
             0421  8946FE          MOV     [BP].sector,AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  49
                  ASSEMBLY LISTING OF OBJECT CODE


             0424  99              CWD
             0425  52              PUSH    DX      ; 4
             0426  50              PUSH    AX      ; 5
             0427  E85A00          CALL    get_file_blocks
             042A  81C40A00        ADD     SP,0AH
             042E  81F80100        CMP     AX,1H
             0432  B80100          MOV     AX,1H
             0435  7501            JNZ     $+3H
             0437  48              DEC     AX
             0438  8886F9FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 780
             043C  C746FC0000      MOV     [BP].offset,0H
                                                   ; STATEMENT # 784
                           @24:
             0441  8B76FC          MOV     SI,[BP].offset
             0444  8A82FAFD        MOV     AL,[BP].s[SI]
             0448  C45E08          LES     BX,[BP].buffer
             044B  8B76FA          MOV     SI,[BP].i
             044E  268800          MOV     ES:[BX].[SI],AL
                                                   ; STATEMENT # 785
             0451  E99CFF          JMP     @21
                           @22:
                                                   ; STATEMENT # 789
             0454  82BEF9FD00      CMP     [BP].error,0H
             0459  7503            JNZ     $+5H
             045B  E92100          JMP     @25
                                                   ; STATEMENT # 791
             045E  C746FA0000      MOV     [BP].i,0H
             0463  E90300          JMP     @28
                           @26:
             0466  FF46FA          INC     [BP].i
                           @28:
             0469  8B5EFA          MOV     BX,[BP].i
             046C  81FB8000        CMP     BX,80H
             0470  7C03            JL      $+5H
             0472  E90A00          JMP     @27
                                                   ; STATEMENT # 792
             0475  C47608          LES     SI,[BP].buffer
             0478  26C60000        MOV     ES:[BX].[SI],0H
             047C  E9E7FF          JMP     @26
                           @27:
                                                   ; STATEMENT # 797
                           @25:
             047F  C9              LEAVE
             0480  5F              POP     DI
             0481  5E              POP     SI
             0482  C3              RET
                                                   ; STATEMENT # 799
                           get_ID3_tag      ENDP
                                                   ; STATEMENT # 842
                           get_file_blocks      PROC NEAR
             0484  56              PUSH    SI
             0485  57              PUSH    DI
             0486  55              PUSH    BP
             0487  8BEC            MOV     BP,SP
                           @29:
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  50
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 849
             0489  C45E0E          LES     BX,[BP].dest
             048C  06              PUSH    ES      ; 1
             048D  53              PUSH    BX      ; 2
             048E  FF760C          PUSH    [BP].length; 3
             0491  FF760A          PUSH    [BP].block+2H; 4
             0494  FF7608          PUSH    [BP].block; 5
             0497  B81C02          MOV     AX,OFFSET(cur_info)
             049A  1E              PUSH    DS      ; 6
             049B  50              PUSH    AX      ; 7
             049C  E8AF09          CALL    get_disk_blocks
             049F  8BE5            MOV     SP,BP
             04A1  5D              POP     BP
             04A2  5F              POP     DI
             04A3  5E              POP     SI
             04A4  C3              RET
                                                   ; STATEMENT # 851
                           get_file_blocks      ENDP
                                                   ; STATEMENT # 901
                           get_first_dir_entry      PROC NEAR
             04A6  56              PUSH    SI
             04A7  57              PUSH    DI
             04A8  C8020000        ENTER   2H,0H
                           @30:
                                                   ; STATEMENT # 903
             04AC  C646FF00        MOV     [BP].error,0H
                                                   ; STATEMENT # 908
             04B0  E87F10          CALL    new_directory
                                                   ; STATEMENT # 911
             04B3  B8D606          MOV     AX,OFFSET(filename)
             04B6  1E              PUSH    DS      ; 1
             04B7  50              PUSH    AX      ; 2
             04B8  B8D605          MOV     AX,OFFSET(dirname)
             04BB  1E              PUSH    DS      ; 3
             04BC  50              PUSH    AX      ; 4
             04BD  E80000          CALL    strcpy_
             04C0  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 914
             04C4  8B161E02        MOV     DX,cur_info+2H
             04C8  8B061C02        MOV     AX,cur_info
             04CC  89060202        MOV     dir_info,AX
             04D0  89160402        MOV     dir_info+2H,DX
                                                   ; STATEMENT # 915
             04D4  8B162202        MOV     DX,cur_info+6H
             04D8  8B062002        MOV     AX,cur_info+4H
             04DC  89060602        MOV     dir_info+4H,AX
             04E0  89160802        MOV     dir_info+6H,DX
                                                   ; STATEMENT # 916
             04E4  8B162602        MOV     DX,cur_info+0AH
             04E8  8B062402        MOV     AX,cur_info+8H
             04EC  89060A02        MOV     dir_info+8H,AX
             04F0  89160C02        MOV     dir_info+0AH,DX
                                                   ; STATEMENT # 917
             04F4  8B162A02        MOV     DX,cur_info+0EH
             04F8  8B062802        MOV     AX,cur_info+0CH
             04FC  89060E02        MOV     dir_info+0CH,AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  51
                  ASSEMBLY LISTING OF OBJECT CODE


             0500  89161002        MOV     dir_info+0EH,DX
                                                   ; STATEMENT # 918
             0504  8B162E02        MOV     DX,cur_info+12H
             0508  8B062C02        MOV     AX,cur_info+10H
             050C  89061202        MOV     dir_info+10H,AX
             0510  89161402        MOV     dir_info+12H,DX
                                                   ; STATEMENT # 920
             0514  C7061602FFFF    MOV     dir_info+14H,0FFFFH
                                                   ; STATEMENT # 925
             051A  C70600020F00    MOV     cur_dir,0FH
                                                   ; STATEMENT # 926
             0520  B8FFFF          MOV     AX,0FFFFH
             0523  89061802        MOV     dir_offset,AX
             0527  89061A02        MOV     dir_offset+2H,AX
                                                   ; STATEMENT # 930
             052B  E80800          CALL    get_next_dir_entry
             052E  8846FF          MOV     [BP].error,AL
                                                   ; STATEMENT # 934
             0531  C9              LEAVE
             0532  5F              POP     DI
             0533  5E              POP     SI
             0534  C3              RET
                                                   ; STATEMENT # 936
                           get_first_dir_entry      ENDP
                                                   ; STATEMENT # 997
                           get_next_dir_entry      PROC NEAR
             0536  56              PUSH    SI
             0537  57              PUSH    DI
             0538  C81C0100        ENTER   11CH,0H
                           @31:
                                                   ; STATEMENT # 1009
             053C  C686E5FE00      MOV     [BP].error,0H
                                                   ; STATEMENT # 1010
             0541  C686E4FE00      MOV     [BP].done,0H
                                                   ; STATEMENT # 1018
             0546  C686E6FE00      MOV     [BP].longfilename,0H
                                                   ; STATEMENT # 1021
             054B  8B161A02        MOV     DX,dir_offset+2H
             054F  8B061802        MOV     AX,dir_offset
             0553  8946EC          MOV     [BP].old_dir_offset,AX
             0556  8956EE          MOV     [BP].old_dir_offset+2H,DX
                                                   ; STATEMENT # 1022
             0559  8B060002        MOV     AX,cur_dir
             055D  8946EA          MOV     [BP].old_cur_dir,AX
                                                   ; STATEMENT # 1026
                           @33:
             0560  82BEE5FE00      CMP     [BP].error,0H
             0565  7403            JZ      $+5H
             0567  E95D06          JMP     @32
             056A  82BEE4FE00      CMP     [BP].done,0H
             056F  7403            JZ      $+5H
             0571  E95306          JMP     @32
                                                   ; STATEMENT # 1029
             0574  813E00020F00    CMP     cur_dir,0FH
             057A  7D03            JGE     $+5H
             057C  E94200          JMP     @34
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  52
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1033
             057F  8B161A02        MOV     DX,dir_offset+2H
             0583  8B061802        MOV     AX,dir_offset
             0587  81C00100        ADD     AX,1H
             058B  81D20000        ADC     DX,0H
             058F  89061802        MOV     dir_offset,AX
             0593  89161A02        MOV     dir_offset+2H,DX
                                                   ; STATEMENT # 1036
             0597  B90000          MOV     CX,OFFSET(dir_sector)
             059A  1E              PUSH    DS      ; 1
             059B  51              PUSH    CX      ; 2
             059C  680100          PUSH    1H
             059F  52              PUSH    DX      ; 4
             05A0  50              PUSH    AX      ; 5
             05A1  B80202          MOV     AX,OFFSET(dir_info)
             05A4  1E              PUSH    DS      ; 6
             05A5  50              PUSH    AX      ; 7
             05A6  E8A508          CALL    get_disk_blocks
             05A9  81C40E00        ADD     SP,0EH
             05AD  81F80100        CMP     AX,1H
             05B1  B80100          MOV     AX,1H
             05B4  7501            JNZ     $+3H
             05B6  48              DEC     AX
             05B7  8886E5FE        MOV     [BP].error,AL
                                                   ; STATEMENT # 1039
             05BB  C7060002FFFF    MOV     cur_dir,0FFFFH
                                                   ; STATEMENT # 1044
                           @34:
             05C1  8B1E0002        MOV     BX,cur_dir
             05C5  81FBFFFF        CMP     BX,0FFFFH
             05C9  7503            JNZ     $+5H
             05CB  E90D00          JMP     @36
             05CE  6BDB20          IMUL    BX,BX,20H
             05D1  82BF000000      CMP     dir_sector[BX],0H
             05D6  7503            JNZ     $+5H
             05D8  E90400          JMP     @35
                           @36:
                                                   ; STATEMENT # 1046
             05DB  FF060002        INC     cur_dir
                                                   ; STATEMENT # 1050
                           @35:
                           @38:
             05DF  82BEE5FE00      CMP     [BP].error,0H
             05E4  7403            JZ      $+5H
             05E6  E9DB05          JMP     @37
             05E9  82BEE4FE00      CMP     [BP].done,0H
             05EE  7403            JZ      $+5H
             05F0  E9D105          JMP     @37
             05F3  8B1E0002        MOV     BX,cur_dir
             05F7  81FB1000        CMP     BX,10H
             05FB  7C03            JL      $+5H
             05FD  E9C405          JMP     @37
                                                   ; STATEMENT # 1053
             0600  6BF320          IMUL    SI,BX,20H
             0603  8A840B00        MOV     AL,dir_sector[SI+0BH]
             0607  B400            MOV     AH,0H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  53
                  ASSEMBLY LISTING OF OBJECT CODE


             0609  81F80F00        CMP     AX,0FH
             060D  7403            JZ      $+5H
             060F  E9C600          JMP     @39
                                                   ; STATEMENT # 1060
             0612  8A840000        MOV     AL,dir_sector[SI]
             0616  B400            MOV     AH,0H
             0618  81E01F00        AND     AX,1FH
             061C  48              DEC     AX
             061D  8946FE          MOV     [BP].lfn_seq,AX
                                                   ; STATEMENT # 1063
             0620  C746E60000      MOV     [BP].k,0H
             0625  E90300          JMP     @42
                           @40:
             0628  FF46E6          INC     [BP].k
                           @42:
             062B  8B5EE6          MOV     BX,[BP].k
             062E  81FB0D00        CMP     BX,0DH
             0632  7C03            JL      $+5H
             0634  E96F00          JMP     @41
                                                   ; STATEMENT # 1065
             0637  81FB0500        CMP     BX,5H
             063B  7C03            JL      $+5H
             063D  E91900          JMP     @43
                                                   ; STATEMENT # 1066
             0640  6B36000220      IMUL    SI,cur_dir,20H
             0645  D1E3            SAL     BX,1
             0647  6B7EFE0D        IMUL    DI,[BP].lfn_seq,0DH
             064B  037EE6          ADD     DI,[BP].k
             064E  8A800100        MOV     AL,[BX].dir_sector[SI+1H]
             0652  8883E6FE        MOV     [BP].longfilename[DI],AL
                                                   ; STATEMENT # 1067
             0656  E94A00          JMP     @44
                           @43:
             0659  8B5EE6          MOV     BX,[BP].k
             065C  81FB0B00        CMP     BX,0BH
             0660  7C03            JL      $+5H
             0662  E91D00          JMP     @45
                                                   ; STATEMENT # 1068
             0665  6B36000220      IMUL    SI,cur_dir,20H
             066A  81EB0500        SUB     BX,5H
             066E  D1E3            SAL     BX,1
             0670  6B7EFE0D        IMUL    DI,[BP].lfn_seq,0DH
             0674  037EE6          ADD     DI,[BP].k
             0677  8A800E00        MOV     AL,[BX].dir_sector[SI+0EH]
             067B  8883E6FE        MOV     [BP].longfilename[DI],AL
                                                   ; STATEMENT # 1069
             067F  E92100          JMP     @46
                           @45:
                                                   ; STATEMENT # 1070
             0682  6B1E000220      IMUL    BX,cur_dir,20H
             0687  8B76E6          MOV     SI,[BP].k
             068A  81EE0500        SUB     SI,5H
             068E  81EE0600        SUB     SI,6H
             0692  D1E6            SAL     SI,1
             0694  6B7EFE0D        IMUL    DI,[BP].lfn_seq,0DH
             0698  037EE6          ADD     DI,[BP].k
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  54
                  ASSEMBLY LISTING OF OBJECT CODE


             069B  8A801C00        MOV     AL,[BX].dir_sector[SI+1CH]
             069F  8883E6FE        MOV     [BP].longfilename[DI],AL
                           @46:
                           @44:
                                                   ; STATEMENT # 1071
             06A3  E982FF          JMP     @40
                           @41:
                                                   ; STATEMENT # 1074
             06A6  8B1E0002        MOV     BX,cur_dir
             06AA  6BF320          IMUL    SI,BX,20H
             06AD  8A840000        MOV     AL,dir_sector[SI]
             06B1  B400            MOV     AH,0H
             06B3  F7C04000        TEST    AX,40H
             06B7  7503            JNZ     $+5H
             06B9  E91500          JMP     @47
                                                   ; STATEMENT # 1076
             06BC  8A840D00        MOV     AL,dir_sector[SI+0DH]
             06C0  B400            MOV     AH,0H
             06C2  8946FC          MOV     [BP].chksum,AX
                                                   ; STATEMENT # 1078
             06C5  8B76FE          MOV     SI,[BP].lfn_seq
             06C8  46              INC     SI
             06C9  6BF60D          IMUL    SI,SI,0DH
             06CC  C682E6FE00      MOV     [BP].longfilename[SI],0H
                                                   ; STATEMENT # 1082
                           @47:
             06D1  FF060002        INC     cur_dir
                                                   ; STATEMENT # 1084
             06D5  E9E904          JMP     @48
                           @39:
                                                   ; STATEMENT # 1088
             06D8  6B1E000220      IMUL    BX,cur_dir,20H
             06DD  8A870000        MOV     AL,dir_sector[BX]
             06E1  98              CBW
             06E2  81F8E5FF        CMP     AX,0FFE5H
             06E6  7403            JZ      $+5H
             06E8  E90C00          JMP     @49
                                                   ; STATEMENT # 1092
             06EB  C686E6FE00      MOV     [BP].longfilename,0H
                                                   ; STATEMENT # 1094
             06F0  FF060002        INC     cur_dir
                                                   ; STATEMENT # 1098
             06F4  E9CA04          JMP     @50
                           @49:
             06F7  6B1E000220      IMUL    BX,cur_dir,20H
             06FC  82BF000000      CMP     dir_sector[BX],0H
             0701  7403            JZ      $+5H
             0703  E95B00          JMP     @51
                                                   ; STATEMENT # 1102
             0706  C686E6FE00      MOV     [BP].longfilename,0H
                                                   ; STATEMENT # 1104
             070B  8B46EA          MOV     AX,[BP].old_cur_dir
             070E  89060002        MOV     cur_dir,AX
                                                   ; STATEMENT # 1106
             0712  8B56EE          MOV     DX,[BP].old_dir_offset+2H
             0715  8B46EC          MOV     AX,[BP].old_dir_offset
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  55
                  ASSEMBLY LISTING OF OBJECT CODE


             0718  3B161A02        CMP     DX,dir_offset+2H
             071C  7504            JNZ     $+6H
             071E  3B061802        CMP     AX,dir_offset
             0722  7503            JNZ     $+5H
             0724  E93200          JMP     @52
                                                   ; STATEMENT # 1109
             0727  B90000          MOV     CX,OFFSET(dir_sector)
             072A  1E              PUSH    DS      ; 1
             072B  51              PUSH    CX      ; 2
             072C  680100          PUSH    1H
             072F  52              PUSH    DX      ; 4
             0730  50              PUSH    AX      ; 5
             0731  B80202          MOV     AX,OFFSET(dir_info)
             0734  1E              PUSH    DS      ; 6
             0735  50              PUSH    AX      ; 7
             0736  E81507          CALL    get_disk_blocks
             0739  81C40E00        ADD     SP,0EH
             073D  81F80100        CMP     AX,1H
             0741  B80100          MOV     AX,1H
             0744  7501            JNZ     $+3H
             0746  48              DEC     AX
             0747  8886E5FE        MOV     [BP].error,AL
                                                   ; STATEMENT # 1111
             074B  8B56EE          MOV     DX,[BP].old_dir_offset+2H
             074E  8B46EC          MOV     AX,[BP].old_dir_offset
             0751  89061802        MOV     dir_offset,AX
             0755  89161A02        MOV     dir_offset+2H,DX
                                                   ; STATEMENT # 1114
                           @52:
             0759  C686E4FE01      MOV     [BP].done,1H
                                                   ; STATEMENT # 1118
             075E  E96004          JMP     @53
                           @51:
             0761  8B1E0002        MOV     BX,cur_dir
             0765  6BF320          IMUL    SI,BX,20H
             0768  8A840000        MOV     AL,dir_sector[SI]
             076C  98              CBW
             076D  81F82E00        CMP     AX,2EH
             0771  7403            JZ      $+5H
             0773  E9E500          JMP     @54
                                                   ; STATEMENT # 1121
             0776  8A840100        MOV     AL,dir_sector[SI+1H]
             077A  98              CBW
             077B  81F82E00        CMP     AX,2EH
             077F  7403            JZ      $+5H
             0781  E9CB00          JMP     @55
                                                   ; STATEMENT # 1125
             0784  E89D0E          CALL    get_dir_tos_sector
             0787  89062C02        MOV     cur_info+10H,AX
             078B  89162E02        MOV     cur_info+12H,DX
                                                   ; STATEMENT # 1126
             078F  E8560E          CALL    get_dir_tos_name
             0792  52              PUSH    DX      ; 1
             0793  50              PUSH    AX      ; 2
             0794  B8D606          MOV     AX,OFFSET(filename)
             0797  1E              PUSH    DS      ; 3
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  56
                  ASSEMBLY LISTING OF OBJECT CODE


             0798  50              PUSH    AX      ; 4
             0799  E80000          CALL    strcpy_
             079C  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 1130
             07A0  813E2E020000    CMP     cur_info+12H,0H
             07A6  7506            JNZ     $+8H
             07A8  813E2C020000    CMP     cur_info+10H,0H
             07AE  7403            JZ      $+5H
             07B0  E92E00          JMP     @56
                                                   ; STATEMENT # 1132
             07B3  8B164602        MOV     DX,root_start_sector+2H
             07B7  8B064402        MOV     AX,root_start_sector
             07BB  89061C02        MOV     cur_info,AX
             07BF  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1133
             07C3  8B164A02        MOV     DX,root_dir_size+2H
             07C7  8B064802        MOV     AX,root_dir_size
             07CB  89062002        MOV     cur_info+4H,AX
             07CF  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1134
             07D3  B8FFFF          MOV     AX,0FFFFH
             07D6  89062402        MOV     cur_info+8H,AX
             07DA  89062602        MOV     cur_info+0AH,AX
                                                   ; STATEMENT # 1136
             07DE  E95500          JMP     @57
                           @56:
                                                   ; STATEMENT # 1138
             07E1  8D46F4          LEA     AX,[BP].e
             07E4  1E              PUSH    DS      ; 1
             07E5  50              PUSH    AX      ; 2
             07E6  FF362E02        PUSH    cur_info+12H; 3
             07EA  FF362C02        PUSH    cur_info+10H; 4
             07EE  E8D50A          CALL    get_contig_sectors
             07F1  81C40800        ADD     SP,8H
             07F5  89062402        MOV     cur_info+8H,AX
             07F9  89162602        MOV     cur_info+0AH,DX
                                                   ; STATEMENT # 1139
             07FD  8B56F6          MOV     DX,[BP].e+2H
             0800  8B46F4          MOV     AX,[BP].e
             0803  81E80200        SUB     AX,2H
             0807  81DA0000        SBB     DX,0H
             080B  8B3E3402        MOV     DI,sectors_per_cluster+2H
             080F  8B0E3202        MOV     CX,sectors_per_cluster
             0813  9A00000000      CALL    LQ_ULONG_MUL
             0818  03064002        ADD     AX,first_file_sector
             081C  13164202        ADC     DX,first_file_sector+2H
             0820  89061C02        MOV     cur_info,AX
             0824  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1140
             0828  8B56FA          MOV     DX,[BP].e+6H
             082B  8B46F8          MOV     AX,[BP].e+4H
             082E  89062002        MOV     cur_info+4H,AX
             0832  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1141
                           @57:
                                                   ; STATEMENT # 1144
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  57
                  ASSEMBLY LISTING OF OBJECT CODE


             0836  B80000          MOV     AX,0H
             0839  89062802        MOV     cur_info+0CH,AX
             083D  89062A02        MOV     cur_info+0EH,AX
                                                   ; STATEMENT # 1146
             0841  C7063002FFFF    MOV     cur_info+14H,0FFFFH
                                                   ; STATEMENT # 1149
             0847  C686E4FE01      MOV     [BP].done,1H
                                                   ; STATEMENT # 1151
             084C  E90900          JMP     @58
                           @55:
                                                   ; STATEMENT # 1155
             084F  C686E6FE00      MOV     [BP].longfilename,0H
                                                   ; STATEMENT # 1157
             0854  FF060002        INC     cur_dir
                                                   ; STATEMENT # 1158
                           @58:
                                                   ; STATEMENT # 1162
             0858  E96603          JMP     @59
                           @54:
             085B  6B1E000220      IMUL    BX,cur_dir,20H
             0860  8A870B00        MOV     AL,dir_sector[BX+0BH]
             0864  B400            MOV     AH,0H
             0866  F7C00800        TEST    AX,8H
             086A  7503            JNZ     $+5H
             086C  E9A300          JMP     @60
                                                   ; STATEMENT # 1165
             086F  823ED60500      CMP     dirname,0H
             0874  7403            JZ      $+5H
             0876  E98D00          JMP     @61
                                                   ; STATEMENT # 1171
             0879  82BEE6FE00      CMP     [BP].longfilename,0H
             087E  7403            JZ      $+5H
             0880  E96E00          JMP     @62
                                                   ; STATEMENT # 1176
             0883  C746E60000      MOV     [BP].k,0H
                                                   ; STATEMENT # 1178
             0888  C746E80000      MOV     [BP].i,0H
             088D  E90300          JMP     @65
                           @63:
             0890  FF46E8          INC     [BP].i
                           @65:
             0893  8B5EE8          MOV     BX,[BP].i
             0896  81FB0800        CMP     BX,8H
             089A  7C03            JL      $+5H
             089C  E91800          JMP     @64
                                                   ; STATEMENT # 1179
             089F  6B36000220      IMUL    SI,cur_dir,20H
             08A4  8B46E6          MOV     AX,[BP].k
             08A7  FF46E6          INC     [BP].k
             08AA  8A880000        MOV     CL,[BX].dir_sector[SI]
             08AE  8BD8            MOV     BX,AX
             08B0  888FD605        MOV     dirname[BX],CL
             08B4  E9D9FF          JMP     @63
                           @64:
                                                   ; STATEMENT # 1182
             08B7  C746E80000      MOV     [BP].i,0H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  58
                  ASSEMBLY LISTING OF OBJECT CODE


             08BC  E90300          JMP     @68
                           @66:
             08BF  FF46E8          INC     [BP].i
                           @68:
             08C2  8B5EE8          MOV     BX,[BP].i
             08C5  81FB0300        CMP     BX,3H
             08C9  7C03            JL      $+5H
             08CB  E91800          JMP     @67
                                                   ; STATEMENT # 1183
             08CE  6B36000220      IMUL    SI,cur_dir,20H
             08D3  8B46E6          MOV     AX,[BP].k
             08D6  FF46E6          INC     [BP].k
             08D9  8A880800        MOV     CL,[BX].dir_sector[SI+8H]
             08DD  8BD8            MOV     BX,AX
             08DF  888FD605        MOV     dirname[BX],CL
             08E3  E9D9FF          JMP     @66
                           @67:
                                                   ; STATEMENT # 1186
             08E6  8B5EE6          MOV     BX,[BP].k
             08E9  C687D60500      MOV     dirname[BX],0H
                                                   ; STATEMENT # 1188
             08EE  E91200          JMP     @69
                           @62:
                                                   ; STATEMENT # 1191
             08F1  8D86E6FE        LEA     AX,[BP].longfilename
             08F5  1E              PUSH    DS      ; 1
             08F6  50              PUSH    AX      ; 2
             08F7  B8D605          MOV     AX,OFFSET(dirname)
             08FA  1E              PUSH    DS      ; 3
             08FB  50              PUSH    AX      ; 4
             08FC  E80000          CALL    strcpy_
             08FF  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 1192
                           @69:
                                                   ; STATEMENT # 1194
             0903  E90000          JMP     @70
                           @61:
                                                   ; STATEMENT # 1199
                           @70:
                                                   ; STATEMENT # 1202
             0906  C686E6FE00      MOV     [BP].longfilename,0H
                                                   ; STATEMENT # 1204
             090B  FF060002        INC     cur_dir
                                                   ; STATEMENT # 1208
             090F  E9AF02          JMP     @71
                           @60:
                                                   ; STATEMENT # 1212
             0912  823ED60700      CMP     fat16,0H
             0917  7503            JNZ     $+5H
             0919  E91500          JMP     @72
                                                   ; STATEMENT # 1213
             091C  6B1E000220      IMUL    BX,cur_dir,20H
             0921  8B871A00        MOV     AX,dir_sector[BX+1AH]
             0925  BA0000          MOV     DX,0H
             0928  8946F0          MOV     [BP].next,AX
             092B  8956F2          MOV     [BP].next+2H,DX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  59
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1214
             092E  E92600          JMP     @73
                           @72:
                                                   ; STATEMENT # 1215
             0931  6B1E000220      IMUL    BX,cur_dir,20H
             0936  8B871400        MOV     AX,dir_sector[BX+14H]
             093A  BA0000          MOV     DX,0H
             093D  B91000          MOV     CX,10H
             0940  D1E0            SHL     AX,1
             0942  D1D2            RCL     DX,1
             0944  E2FA            LOOP    $-4H
             0946  8B8F1A00        MOV     CX,dir_sector[BX+1AH]
             094A  BF0000          MOV     DI,0H
             094D  0BC1            OR      AX,CX
             094F  0BD7            OR      DX,DI
             0951  8946F0          MOV     [BP].next,AX
             0954  8956F2          MOV     [BP].next+2H,DX
                           @73:
                                                   ; STATEMENT # 1220
             0957  C746E80000      MOV     [BP].i,0H
             095C  E90300          JMP     @76
                           @74:
             095F  FF46E8          INC     [BP].i
                           @76:
             0962  8B46E8          MOV     AX,[BP].i
             0965  40              INC     AX
             0966  81F80008        CMP     AX,800H
             096A  7203            JB      $+5H
             096C  E95700          JMP     @75
             096F  8B56F2          MOV     DX,[BP].next+2H
             0972  8B46F0          MOV     AX,[BP].next
             0975  81FAFFFF        CMP     DX,0FFFFH
             0979  7504            JNZ     $+6H
             097B  81F8FFFF        CMP     AX,0FFFFH
             097F  7503            JNZ     $+5H
             0981  E94200          JMP     @75
                                                   ; STATEMENT # 1223
             0984  8D4EF4          LEA     CX,[BP].e
             0987  1E              PUSH    DS      ; 1
             0988  51              PUSH    CX      ; 2
             0989  52              PUSH    DX      ; 3
             098A  50              PUSH    AX      ; 4
             098B  E83809          CALL    get_contig_sectors
             098E  81C40800        ADD     SP,8H
             0992  8946F0          MOV     [BP].next,AX
             0995  8956F2          MOV     [BP].next+2H,DX
                                                   ; STATEMENT # 1226
             0998  6B5EE808        IMUL    BX,[BP].i,8H
             099C  8B56F6          MOV     DX,[BP].e+2H
             099F  8B46F4          MOV     AX,[BP].e
             09A2  C4364C02        LES     SI,FAT_cache
             09A6  268900          MOV     ES:[BX].[SI],AX
             09A9  26895002        MOV     ES:[BX].[SI+2H],DX
                                                   ; STATEMENT # 1227
             09AD  6B5EE808        IMUL    BX,[BP].i,8H
             09B1  8B56FA          MOV     DX,[BP].e+6H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  60
                  ASSEMBLY LISTING OF OBJECT CODE


             09B4  8B46F8          MOV     AX,[BP].e+4H
             09B7  C4364C02        LES     SI,FAT_cache
             09BB  26894004        MOV     ES:[BX].[SI+4H],AX
             09BF  26895006        MOV     ES:[BX].[SI+6H],DX
                                                   ; STATEMENT # 1228
             09C3  E999FF          JMP     @74
                           @75:
                                                   ; STATEMENT # 1232
             09C6  8B5EE8          MOV     BX,[BP].i
             09C9  81FB0008        CMP     BX,800H
             09CD  7203            JB      $+5H
             09CF  E92700          JMP     @77
                                                   ; STATEMENT # 1233
             09D2  6BDB08          IMUL    BX,BX,8H
             09D5  8B56F2          MOV     DX,[BP].next+2H
             09D8  8B46F0          MOV     AX,[BP].next
             09DB  C4364C02        LES     SI,FAT_cache
             09DF  268900          MOV     ES:[BX].[SI],AX
             09E2  26895002        MOV     ES:[BX].[SI+2H],DX
                                                   ; STATEMENT # 1234
             09E6  6B5EE808        IMUL    BX,[BP].i,8H
             09EA  C4364C02        LES     SI,FAT_cache
             09EE  B80000          MOV     AX,0H
             09F1  26894004        MOV     ES:[BX].[SI+4H],AX
             09F5  26894006        MOV     ES:[BX].[SI+6H],AX
                                                   ; STATEMENT # 1239
                           @77:
             09F9  823ED60700      CMP     fat16,0H
             09FE  7503            JNZ     $+5H
             0A00  E91700          JMP     @78
                                                   ; STATEMENT # 1240
             0A03  6B1E000220      IMUL    BX,cur_dir,20H
             0A08  8B871A00        MOV     AX,dir_sector[BX+1AH]
             0A0C  BA0000          MOV     DX,0H
             0A0F  89062C02        MOV     cur_info+10H,AX
             0A13  89162E02        MOV     cur_info+12H,DX
                                                   ; STATEMENT # 1241
             0A17  E92800          JMP     @79
                           @78:
                                                   ; STATEMENT # 1242
             0A1A  6B1E000220      IMUL    BX,cur_dir,20H
             0A1F  8B871400        MOV     AX,dir_sector[BX+14H]
             0A23  BA0000          MOV     DX,0H
             0A26  B91000          MOV     CX,10H
             0A29  D1E0            SHL     AX,1
             0A2B  D1D2            RCL     DX,1
             0A2D  E2FA            LOOP    $-4H
             0A2F  8B8F1A00        MOV     CX,dir_sector[BX+1AH]
             0A33  BF0000          MOV     DI,0H
             0A36  0BC1            OR      AX,CX
             0A38  0BD7            OR      DX,DI
             0A3A  89062C02        MOV     cur_info+10H,AX
             0A3E  89162E02        MOV     cur_info+12H,DX
                           @79:
                                                   ; STATEMENT # 1244
             0A42  B80000          MOV     AX,0H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  61
                  ASSEMBLY LISTING OF OBJECT CODE


             0A45  89062802        MOV     cur_info+0CH,AX
             0A49  89062A02        MOV     cur_info+0EH,AX
                                                   ; STATEMENT # 1247
                                                   ; STATEMENT # 1250
             0A4D  C41E4C02        LES     BX,FAT_cache
             0A51  268B5702        MOV     DX,ES:[BX+2H]
             0A55  268B07          MOV     AX,ES:[BX]
             0A58  81E80200        SUB     AX,2H
             0A5C  81DA0000        SBB     DX,0H
             0A60  8B3E3402        MOV     DI,sectors_per_cluster+2H
             0A64  8B0E3202        MOV     CX,sectors_per_cluster
             0A68  9A00000000      CALL    LQ_ULONG_MUL
             0A6D  03064002        ADD     AX,first_file_sector
             0A71  13164202        ADC     DX,first_file_sector+2H
             0A75  89061C02        MOV     cur_info,AX
             0A79  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1251
             0A7D  8B1E4C02        MOV     BX,FAT_cache
             0A81  268B5706        MOV     DX,ES:[BX+6H]
             0A85  268B4704        MOV     AX,ES:[BX+4H]
             0A89  89062002        MOV     cur_info+4H,AX
             0A8D  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1252
             0A91  268B570A        MOV     DX,ES:[BX+0AH]
             0A95  268B4708        MOV     AX,ES:[BX+8H]
             0A99  89062402        MOV     cur_info+8H,AX
             0A9D  89162602        MOV     cur_info+0AH,DX
                                                   ; STATEMENT # 1254
             0AA1  C70630020000    MOV     cur_info+14H,0H
                                                   ; STATEMENT # 1256
             0AA7  E95B00          JMP     @81
                           @80:
                                                   ; STATEMENT # 1260
             0AAA  8D46F4          LEA     AX,[BP].e
             0AAD  1E              PUSH    DS      ; 1
             0AAE  50              PUSH    AX      ; 2
             0AAF  FF362E02        PUSH    cur_info+12H; 3
             0AB3  FF362C02        PUSH    cur_info+10H; 4
             0AB7  E80C08          CALL    get_contig_sectors
             0ABA  81C40800        ADD     SP,8H
             0ABE  89062402        MOV     cur_info+8H,AX
             0AC2  89162602        MOV     cur_info+0AH,DX
                                                   ; STATEMENT # 1262
             0AC6  8B56F6          MOV     DX,[BP].e+2H
             0AC9  8B46F4          MOV     AX,[BP].e
             0ACC  81E80200        SUB     AX,2H
             0AD0  81DA0000        SBB     DX,0H
             0AD4  8B3E3402        MOV     DI,sectors_per_cluster+2H
             0AD8  8B0E3202        MOV     CX,sectors_per_cluster
             0ADC  9A00000000      CALL    LQ_ULONG_MUL
             0AE1  03064002        ADD     AX,first_file_sector
             0AE5  13164202        ADC     DX,first_file_sector+2H
             0AE9  89061C02        MOV     cur_info,AX
             0AED  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1263
             0AF1  8B56FA          MOV     DX,[BP].e+6H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  62
                  ASSEMBLY LISTING OF OBJECT CODE


             0AF4  8B46F8          MOV     AX,[BP].e+4H
             0AF7  89062002        MOV     cur_info+4H,AX
             0AFB  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1265
             0AFF  C7063002FFFF    MOV     cur_info+14H,0FFFFH
                                                   ; STATEMENT # 1266
                           @81:
                                                   ; STATEMENT # 1271
             0B05  82BEE6FE00      CMP     [BP].longfilename,0H
             0B0A  7403            JZ      $+5H
             0B0C  E99B00          JMP     @82
                                                   ; STATEMENT # 1276
             0B0F  C746E60000      MOV     [BP].k,0H
                                                   ; STATEMENT # 1278
             0B14  C746E80000      MOV     [BP].i,0H
             0B19  E90300          JMP     @85
                           @83:
             0B1C  FF46E8          INC     [BP].i
                           @85:
             0B1F  8B5EE8          MOV     BX,[BP].i
             0B22  81FB0800        CMP     BX,8H
             0B26  7C03            JL      $+5H
             0B28  E92800          JMP     @84
             0B2B  8B360002        MOV     SI,cur_dir
             0B2F  6BFE20          IMUL    DI,SI,20H
             0B32  8A810000        MOV     AL,[BX].dir_sector[DI]
             0B36  98              CBW
             0B37  81F82000        CMP     AX,20H
             0B3B  7503            JNZ     $+5H
             0B3D  E91300          JMP     @84
                                                   ; STATEMENT # 1279
             0B40  8B46E6          MOV     AX,[BP].k
             0B43  FF46E6          INC     [BP].k
             0B46  8A890000        MOV     CL,[BX].dir_sector[DI]
             0B4A  8BD8            MOV     BX,AX
             0B4C  888FD606        MOV     filename[BX],CL
             0B50  E9C9FF          JMP     @83
                           @84:
                                                   ; STATEMENT # 1282
             0B53  8B46E6          MOV     AX,[BP].k
             0B56  FF46E6          INC     [BP].k
             0B59  8BD8            MOV     BX,AX
             0B5B  C687D6062E      MOV     filename[BX],2EH
                                                   ; STATEMENT # 1285
             0B60  C746E80000      MOV     [BP].i,0H
             0B65  E90300          JMP     @88
                           @86:
             0B68  FF46E8          INC     [BP].i
                           @88:
             0B6B  8B5EE8          MOV     BX,[BP].i
             0B6E  81FB0300        CMP     BX,3H
             0B72  7C03            JL      $+5H
             0B74  E92800          JMP     @87
             0B77  8B360002        MOV     SI,cur_dir
             0B7B  6BFE20          IMUL    DI,SI,20H
             0B7E  8A810800        MOV     AL,[BX].dir_sector[DI+8H]
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  63
                  ASSEMBLY LISTING OF OBJECT CODE


             0B82  98              CBW
             0B83  81F82000        CMP     AX,20H
             0B87  7503            JNZ     $+5H
             0B89  E91300          JMP     @87
                                                   ; STATEMENT # 1286
             0B8C  8B46E6          MOV     AX,[BP].k
             0B8F  FF46E6          INC     [BP].k
             0B92  8A890800        MOV     CL,[BX].dir_sector[DI+8H]
             0B96  8BD8            MOV     BX,AX
             0B98  888FD606        MOV     filename[BX],CL
             0B9C  E9C9FF          JMP     @86
                           @87:
                                                   ; STATEMENT # 1289
             0B9F  8B5EE6          MOV     BX,[BP].k
             0BA2  C687D60600      MOV     filename[BX],0H
                                                   ; STATEMENT # 1291
             0BA7  E91200          JMP     @89
                           @82:
                                                   ; STATEMENT # 1294
             0BAA  8D86E6FE        LEA     AX,[BP].longfilename
             0BAE  1E              PUSH    DS      ; 1
             0BAF  50              PUSH    AX      ; 2
             0BB0  B8D606          MOV     AX,OFFSET(filename)
             0BB3  1E              PUSH    DS      ; 3
             0BB4  50              PUSH    AX      ; 4
             0BB5  E80000          CALL    strcpy_
             0BB8  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 1295
                           @89:
                                                   ; STATEMENT # 1298
             0BBC  C686E4FE01      MOV     [BP].done,1H
                                                   ; STATEMENT # 1299
                           @71:
                           @59:
                           @53:
                           @50:
                                                   ; STATEMENT # 1300
                           @48:
                                                   ; STATEMENT # 1301
             0BC1  E91BFA          JMP     @38
                           @37:
                                                   ; STATEMENT # 1302
             0BC4  E999F9          JMP     @33
                           @32:
                                                   ; STATEMENT # 1306
             0BC7  82BEE5FE00      CMP     [BP].error,0H
             0BCC  7503            JNZ     $+5H
             0BCE  E94D00          JMP     @90
                                                   ; STATEMENT # 1309
             0BD1  C606D60600      MOV     filename,0H
                                                   ; STATEMENT # 1311
             0BD6  8B164202        MOV     DX,first_file_sector+2H
             0BDA  8B064002        MOV     AX,first_file_sector
             0BDE  89061C02        MOV     cur_info,AX
             0BE2  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1312
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  64
                  ASSEMBLY LISTING OF OBJECT CODE


             0BE6  8B163402        MOV     DX,sectors_per_cluster+2H
             0BEA  8B063202        MOV     AX,sectors_per_cluster
             0BEE  89062002        MOV     cur_info+4H,AX
             0BF2  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1313
             0BF6  B8FFFF          MOV     AX,0FFFFH
             0BF9  89062402        MOV     cur_info+8H,AX
             0BFD  89062602        MOV     cur_info+0AH,AX
                                                   ; STATEMENT # 1314
             0C01  B80000          MOV     AX,0H
             0C04  89062802        MOV     cur_info+0CH,AX
             0C08  89062A02        MOV     cur_info+0EH,AX
                                                   ; STATEMENT # 1315
             0C0C  C7062C020200    MOV     cur_info+10H,2H
             0C12  C7062E020000    MOV     cur_info+12H,0H
                                                   ; STATEMENT # 1316
             0C18  C7063002FFFF    MOV     cur_info+14H,0FFFFH
                                                   ; STATEMENT # 1321
                           @90:
             0C1E  8A86E5FE        MOV     AL,[BP].error
             0C22  C9              LEAVE
             0C23  5F              POP     DI
             0C24  5E              POP     SI
             0C25  C3              RET
                                                   ; STATEMENT # 1323
                           get_next_dir_entry      ENDP
                                                   ; STATEMENT # 1377
                           get_previous_dir_entry      PROC NEAR
             0C26  56              PUSH    SI
             0C27  57              PUSH    DI
             0C28  C80A0000        ENTER   0AH,0H
                           @91:
                                                   ; STATEMENT # 1382
             0C2C  C646F900        MOV     [BP].error,0H
                                                   ; STATEMENT # 1383
             0C30  C646F800        MOV     [BP].done,0H
                                                   ; STATEMENT # 1384
             0C34  C646F700        MOV     [BP].have_entry,0H
                                                   ; STATEMENT # 1390
                           @93:
             0C38  827EF900        CMP     [BP].error,0H
             0C3C  7403            JZ      $+5H
             0C3E  E93B01          JMP     @92
             0C41  827EF800        CMP     [BP].done,0H
             0C45  7403            JZ      $+5H
             0C47  E93201          JMP     @92
                                                   ; STATEMENT # 1393
             0C4A  833E000200      CMP     cur_dir,0H
             0C4F  7403            JZ      $+5H
             0C51  E96C00          JMP     @94
                                                   ; STATEMENT # 1397
             0C54  813E1A020000    CMP     dir_offset+2H,0H
             0C5A  7506            JNZ     $+8H
             0C5C  813E18020000    CMP     dir_offset,0H
             0C62  7403            JZ      $+5H
             0C64  E91500          JMP     @95
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  65
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1399
             0C67  B80000          MOV     AX,0H
             0C6A  8946FC          MOV     [BP].new_offset,AX
             0C6D  8946FE          MOV     [BP].new_offset+2H,AX
                                                   ; STATEMENT # 1400
             0C70  C746FA0000      MOV     [BP].new_entry,0H
                                                   ; STATEMENT # 1402
             0C75  C646F801        MOV     [BP].done,1H
                                                   ; STATEMENT # 1404
             0C79  E94100          JMP     @96
                           @95:
                                                   ; STATEMENT # 1408
             0C7C  B80000          MOV     AX,OFFSET(dir_sector)
             0C7F  1E              PUSH    DS      ; 1
             0C80  50              PUSH    AX      ; 2
             0C81  680100          PUSH    1H
             0C84  8B161A02        MOV     DX,dir_offset+2H
             0C88  8B061802        MOV     AX,dir_offset
             0C8C  81E80100        SUB     AX,1H
             0C90  81DA0000        SBB     DX,0H
             0C94  89061802        MOV     dir_offset,AX
             0C98  89161A02        MOV     dir_offset+2H,DX
             0C9C  52              PUSH    DX      ; 4
             0C9D  50              PUSH    AX      ; 5
             0C9E  B80202          MOV     AX,OFFSET(dir_info)
             0CA1  1E              PUSH    DS      ; 6
             0CA2  50              PUSH    AX      ; 7
             0CA3  E8A801          CALL    get_disk_blocks
             0CA6  81C40E00        ADD     SP,0EH
             0CAA  81F80100        CMP     AX,1H
             0CAE  B80100          MOV     AX,1H
             0CB1  7501            JNZ     $+3H
             0CB3  48              DEC     AX
             0CB4  8846F9          MOV     [BP].error,AL
                                                   ; STATEMENT # 1410
             0CB7  C70600020F00    MOV     cur_dir,0FH
                                                   ; STATEMENT # 1411
                           @96:
                                                   ; STATEMENT # 1413
             0CBD  E90400          JMP     @97
                           @94:
                                                   ; STATEMENT # 1416
             0CC0  FF0E0002        DEC     cur_dir
                                                   ; STATEMENT # 1417
                           @97:
                                                   ; STATEMENT # 1421
             0CC4  827EF800        CMP     [BP].done,0H
             0CC8  7403            JZ      $+5H
             0CCA  E9AC00          JMP     @98
             0CCD  827EF900        CMP     [BP].error,0H
             0CD1  7403            JZ      $+5H
             0CD3  E9A300          JMP     @98
                                                   ; STATEMENT # 1424
             0CD6  827EF700        CMP     [BP].have_entry,0H
             0CDA  7503            JNZ     $+5H
             0CDC  E93300          JMP     @99
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  66
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1428
             0CDF  6B1E000220      IMUL    BX,cur_dir,20H
             0CE4  8A870B00        MOV     AL,dir_sector[BX+0BH]
             0CE8  B400            MOV     AH,0H
             0CEA  81F80F00        CMP     AX,0FH
             0CEE  7503            JNZ     $+5H
             0CF0  E90700          JMP     @100
                                                   ; STATEMENT # 1430
             0CF3  C646F801        MOV     [BP].done,1H
                                                   ; STATEMENT # 1432
             0CF7  E91500          JMP     @101
                           @100:
                                                   ; STATEMENT # 1435
             0CFA  8B161A02        MOV     DX,dir_offset+2H
             0CFE  8B061802        MOV     AX,dir_offset
             0D02  8946FC          MOV     [BP].new_offset,AX
             0D05  8956FE          MOV     [BP].new_offset+2H,DX
                                                   ; STATEMENT # 1436
             0D08  8B060002        MOV     AX,cur_dir
             0D0C  8946FA          MOV     [BP].new_entry,AX
                                                   ; STATEMENT # 1437
                           @101:
                                                   ; STATEMENT # 1439
             0D0F  E96700          JMP     @102
                           @99:
                                                   ; STATEMENT # 1449
             0D12  8B1E0002        MOV     BX,cur_dir
             0D16  6BF320          IMUL    SI,BX,20H
             0D19  8A840000        MOV     AL,dir_sector[SI]
             0D1D  08C0            OR      AL,AL
             0D1F  7503            JNZ     $+5H
             0D21  E95500          JMP     @103
             0D24  98              CBW
             0D25  81F8E5FF        CMP     AX,0FFE5H
             0D29  7503            JNZ     $+5H
             0D2B  E94B00          JMP     @103
             0D2E  8A8C0B00        MOV     CL,dir_sector[SI+0BH]
             0D32  B500            MOV     CH,0H
             0D34  81F90F00        CMP     CX,0FH
             0D38  7503            JNZ     $+5H
             0D3A  E93C00          JMP     @103
             0D3D  81F90800        CMP     CX,8H
             0D41  7503            JNZ     $+5H
             0D43  E93300          JMP     @103
             0D46  81F82E00        CMP     AX,2EH
             0D4A  7403            JZ      $+5H
             0D4C  E90E00          JMP     @104
             0D4F  8A840100        MOV     AL,dir_sector[SI+1H]
             0D53  98              CBW
             0D54  81F82E00        CMP     AX,2EH
             0D58  7403            JZ      $+5H
             0D5A  E91C00          JMP     @103
                           @104:
                                                   ; STATEMENT # 1452
             0D5D  C646F701        MOV     [BP].have_entry,1H
                                                   ; STATEMENT # 1454
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  67
                  ASSEMBLY LISTING OF OBJECT CODE


             0D61  8B161A02        MOV     DX,dir_offset+2H
             0D65  8B061802        MOV     AX,dir_offset
             0D69  8946FC          MOV     [BP].new_offset,AX
             0D6C  8956FE          MOV     [BP].new_offset+2H,DX
                                                   ; STATEMENT # 1455
             0D6F  8B060002        MOV     AX,cur_dir
             0D73  8946FA          MOV     [BP].new_entry,AX
                                                   ; STATEMENT # 1457
             0D76  E90000          JMP     @105
                           @103:
                                                   ; STATEMENT # 1461
                           @105:
                                                   ; STATEMENT # 1462
                           @102:
                                                   ; STATEMENT # 1464
                           @98:
             0D79  E9BCFE          JMP     @93
                           @92:
                                                   ; STATEMENT # 1467
             0D7C  827EF900        CMP     [BP].error,0H
             0D80  7403            JZ      $+5H
             0D82  E94E00          JMP     @106
                                                   ; STATEMENT # 1470
             0D85  8B56FE          MOV     DX,[BP].new_offset+2H
             0D88  8B46FC          MOV     AX,[BP].new_offset
             0D8B  3B161A02        CMP     DX,dir_offset+2H
             0D8F  7504            JNZ     $+6H
             0D91  3B061802        CMP     AX,dir_offset
             0D95  7503            JNZ     $+5H
             0D97  E92300          JMP     @107
                                                   ; STATEMENT # 1472
             0D9A  B90000          MOV     CX,OFFSET(dir_sector)
             0D9D  1E              PUSH    DS      ; 1
             0D9E  51              PUSH    CX      ; 2
             0D9F  680100          PUSH    1H
             0DA2  52              PUSH    DX      ; 4
             0DA3  50              PUSH    AX      ; 5
             0DA4  B80202          MOV     AX,OFFSET(dir_info)
             0DA7  1E              PUSH    DS      ; 6
             0DA8  50              PUSH    AX      ; 7
             0DA9  E8A200          CALL    get_disk_blocks
             0DAC  81C40E00        ADD     SP,0EH
             0DB0  81F80100        CMP     AX,1H
             0DB4  B80100          MOV     AX,1H
             0DB7  7501            JNZ     $+3H
             0DB9  48              DEC     AX
             0DBA  8846F9          MOV     [BP].error,AL
                                                   ; STATEMENT # 1474
                           @107:
             0DBD  8B56FE          MOV     DX,[BP].new_offset+2H
             0DC0  8B46FC          MOV     AX,[BP].new_offset
             0DC3  89061802        MOV     dir_offset,AX
             0DC7  89161A02        MOV     dir_offset+2H,DX
                                                   ; STATEMENT # 1475
             0DCB  8B46FA          MOV     AX,[BP].new_entry
             0DCE  48              DEC     AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  68
                  ASSEMBLY LISTING OF OBJECT CODE


             0DCF  89060002        MOV     cur_dir,AX
                                                   ; STATEMENT # 1480
                           @106:
             0DD3  827EF900        CMP     [BP].error,0H
             0DD7  B90100          MOV     CX,1H
             0DDA  7401            JZ      $+3H
             0DDC  49              DEC     CX
             0DDD  B500            MOV     CH,0H
             0DDF  8A46F8          MOV     AL,[BP].done
             0DE2  98              CBW
             0DE3  85C8            TEST    CX,AX
             0DE5  7503            JNZ     $+5H
             0DE7  E90600          JMP     @108
                                                   ; STATEMENT # 1485
             0DEA  E849F7          CALL    get_next_dir_entry
             0DED  8846F9          MOV     [BP].error,AL
                                                   ; STATEMENT # 1492
                           @108:
             0DF0  827EF900        CMP     [BP].error,0H
             0DF4  7503            JNZ     $+5H
             0DF6  E94D00          JMP     @109
                                                   ; STATEMENT # 1495
             0DF9  C606D60600      MOV     filename,0H
                                                   ; STATEMENT # 1497
             0DFE  8B164202        MOV     DX,first_file_sector+2H
             0E02  8B064002        MOV     AX,first_file_sector
             0E06  89061C02        MOV     cur_info,AX
             0E0A  89161E02        MOV     cur_info+2H,DX
                                                   ; STATEMENT # 1498
             0E0E  8B163402        MOV     DX,sectors_per_cluster+2H
             0E12  8B063202        MOV     AX,sectors_per_cluster
             0E16  89062002        MOV     cur_info+4H,AX
             0E1A  89162202        MOV     cur_info+6H,DX
                                                   ; STATEMENT # 1499
             0E1E  B8FFFF          MOV     AX,0FFFFH
             0E21  89062402        MOV     cur_info+8H,AX
             0E25  89062602        MOV     cur_info+0AH,AX
                                                   ; STATEMENT # 1500
             0E29  B80000          MOV     AX,0H
             0E2C  89062802        MOV     cur_info+0CH,AX
             0E30  89062A02        MOV     cur_info+0EH,AX
                                                   ; STATEMENT # 1501
             0E34  C7062C020200    MOV     cur_info+10H,2H
             0E3A  C7062E020000    MOV     cur_info+12H,0H
                                                   ; STATEMENT # 1502
             0E40  C70630020000    MOV     cur_info+14H,0H
                                                   ; STATEMENT # 1507
                           @109:
             0E46  8A46F9          MOV     AL,[BP].error
             0E49  C9              LEAVE
             0E4A  5F              POP     DI
             0E4B  5E              POP     SI
             0E4C  C3              RET
                                                   ; STATEMENT # 1509
                           get_previous_dir_entry      ENDP
                                                   ; STATEMENT # 1561
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  69
                  ASSEMBLY LISTING OF OBJECT CODE


                           get_disk_blocks      PROC NEAR
             0E4E  56              PUSH    SI
             0E4F  57              PUSH    DI
             0E50  C8080000        ENTER   8H,0H
                           @110:
                                                   ; STATEMENT # 1563
             0E54  C746FE0000      MOV     [BP].sectors_read,0H
                                                   ; STATEMENT # 1568
             0E59  C646F900        MOV     [BP].error,0H
                                                   ; STATEMENT # 1573
                           @112:
             0E5D  827EF900        CMP     [BP].error,0H
             0E61  7403            JZ      $+5H
             0E63  E9F300          JMP     @111
             0E66  8B4610          MOV     AX,[BP].length
             0E69  3B46FE          CMP     AX,[BP].sectors_read
             0E6C  7F03            JG      $+5H
             0E6E  E9E800          JMP     @111
                                                   ; STATEMENT # 1576
             0E71  C45E08          LES     BX,[BP].info
             0E74  268B570E        MOV     DX,ES:block_info[BX+0EH]
             0E78  268B470C        MOV     AX,ES:block_info[BX+0CH]
             0E7C  8B7E0E          MOV     DI,[BP].block+2H
             0E7F  8B4E0C          MOV     CX,[BP].block
             0E82  3BD7            CMP     DX,DI
             0E84  7502            JNZ     $+4H
             0E86  3BC1            CMP     AX,CX
             0E88  7603            JBE     $+5H
             0E8A  E91300          JMP     @114
             0E8D  26034704        ADD     AX,ES:block_info[BX+4H]
             0E91  26135706        ADC     DX,ES:block_info[BX+6H]
             0E95  3BD7            CMP     DX,DI
             0E97  7502            JNZ     $+4H
             0E99  3BC1            CMP     AX,CX
             0E9B  7603            JBE     $+5H
             0E9D  E91200          JMP     @113
                           @114:
                                                   ; STATEMENT # 1578
             0EA0  FF760E          PUSH    [BP].block+2H; 1
             0EA3  FF760C          PUSH    [BP].block; 2
             0EA6  C45E08          LES     BX,[BP].info
             0EA9  06              PUSH    ES      ; 3
             0EAA  53              PUSH    BX      ; 4
             0EAB  E8B200          CALL    get_block_info
             0EAE  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 1582
                           @113:
             0EB2  C45E08          LES     BX,[BP].info
             0EB5  268B570E        MOV     DX,ES:block_info[BX+0EH]
             0EB9  268B4F0C        MOV     CX,ES:block_info[BX+0CH]
             0EBD  26034F04        ADD     CX,ES:block_info[BX+4H]
             0EC1  26135706        ADC     DX,ES:block_info[BX+6H]
             0EC5  2B4E0C          SUB     CX,[BP].block
             0EC8  1B560E          SBB     DX,[BP].block+2H
             0ECB  8B4610          MOV     AX,[BP].length
             0ECE  8B5EFE          MOV     BX,[BP].sectors_read
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  70
                  ASSEMBLY LISTING OF OBJECT CODE


             0ED1  2BC3            SUB     AX,BX
             0ED3  52              PUSH    DX      ; 1
             0ED4  99              CWD
             0ED5  5F              POP     DI      ; 1
             0ED6  3BFA            CMP     DI,DX
             0ED8  7502            JNZ     $+4H
             0EDA  3BC8            CMP     CX,AX
             0EDC  7303            JAE     $+5H
             0EDE  E90B00          JMP     @115
                                                   ; STATEMENT # 1584
             0EE1  8B4610          MOV     AX,[BP].length
             0EE4  2BC3            SUB     AX,BX
             0EE6  8946FC          MOV     [BP].xfer_cnt,AX
                                                   ; STATEMENT # 1585
             0EE9  E91C00          JMP     @116
                           @115:
                                                   ; STATEMENT # 1587
             0EEC  C45E08          LES     BX,[BP].info
             0EEF  268B570E        MOV     DX,ES:block_info[BX+0EH]
             0EF3  268B470C        MOV     AX,ES:block_info[BX+0CH]
             0EF7  26034704        ADD     AX,ES:block_info[BX+4H]
             0EFB  26135706        ADC     DX,ES:block_info[BX+6H]
             0EFF  2B460C          SUB     AX,[BP].block
             0F02  1B560E          SBB     DX,[BP].block+2H
             0F05  8946FC          MOV     [BP].xfer_cnt,AX
                           @116:
                                                   ; STATEMENT # 1590
             0F08  C45E12          LES     BX,[BP].dest
             0F0B  06              PUSH    ES      ; 1
             0F0C  53              PUSH    BX      ; 2
             0F0D  FF76FC          PUSH    [BP].xfer_cnt; 3
             0F10  8B560E          MOV     DX,[BP].block+2H
             0F13  8B460C          MOV     AX,[BP].block
             0F16  C45E08          LES     BX,[BP].info
             0F19  260307          ADD     AX,ES:block_info[BX]
             0F1C  26135702        ADC     DX,ES:block_info[BX+2H]
             0F20  262B470C        SUB     AX,ES:block_info[BX+0CH]
             0F24  261B570E        SBB     DX,ES:block_info[BX+0EH]
             0F28  52              PUSH    DX      ; 4
             0F29  50              PUSH    AX      ; 5
             0F2A  E80000          CALL    get_blocks
             0F2D  81C40A00        ADD     SP,0AH
             0F31  8946FA          MOV     [BP].blk_cnt,AX
                                                   ; STATEMENT # 1593
             0F34  99              CWD
             0F35  01460C          ADD     [BP].block,AX
             0F38  11560E          ADC     [BP].block+2H,DX
                                                   ; STATEMENT # 1594
             0F3B  8B46FA          MOV     AX,[BP].blk_cnt
             0F3E  0146FE          ADD     [BP].sectors_read,AX
                                                   ; STATEMENT # 1595
             0F41  69C80001        IMUL    CX,AX,100H
             0F45  D1E1            SAL     CX,1
             0F47  014E12          ADD     [BP].dest,CX
                                                   ; STATEMENT # 1598
             0F4A  3946FC          CMP     [BP].xfer_cnt,AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  71
                  ASSEMBLY LISTING OF OBJECT CODE


             0F4D  7F03            JG      $+5H
             0F4F  E90400          JMP     @117
                                                   ; STATEMENT # 1600
             0F52  C646F901        MOV     [BP].error,1H
                                                   ; STATEMENT # 1601
                           @117:
             0F56  E904FF          JMP     @112
                           @111:
                                                   ; STATEMENT # 1605
             0F59  8B46FE          MOV     AX,[BP].sectors_read
             0F5C  C9              LEAVE
             0F5D  5F              POP     DI
             0F5E  5E              POP     SI
             0F5F  C3              RET
                                                   ; STATEMENT # 1607
                           get_disk_blocks      ENDP
                                                   ; STATEMENT # 1646
                           get_block_info      PROC NEAR
             0F60  56              PUSH    SI
             0F61  57              PUSH    DI
             0F62  C80A0000        ENTER   0AH,0H
                           @118:
                                                   ; STATEMENT # 1650
             0F66  C646F700        MOV     [BP].have_block,0H
                                                   ; STATEMENT # 1658
                           @120:
             0F6A  827EF700        CMP     [BP].have_block,0H
             0F6E  7403            JZ      $+5H
             0F70  E9DE00          JMP     @119
             0F73  C45E08          LES     BX,[BP].info
             0F76  268B4714        MOV     AX,ES:block_info[BX+14H]
             0F7A  81F8FFFF        CMP     AX,0FFFFH
             0F7E  7503            JNZ     $+5H
             0F80  E9CE00          JMP     @119
             0F83  40              INC     AX
             0F84  81F80008        CMP     AX,800H
             0F88  7203            JB      $+5H
             0F8A  E9C400          JMP     @119
             0F8D  26817F0AFFFF    CMP     ES:block_info[BX+0AH],0FFFFH
             0F93  7506            JNZ     $+8H
             0F95  26817F08FFFF    CMP     ES:block_info[BX+8H],0FFFFH
             0F9B  7503            JNZ     $+5H
             0F9D  E9B100          JMP     @119
             0FA0  268B570E        MOV     DX,ES:block_info[BX+0EH]
             0FA4  268B470C        MOV     AX,ES:block_info[BX+0CH]
             0FA8  268B7F06        MOV     DI,ES:block_info[BX+6H]
             0FAC  268B4F04        MOV     CX,ES:block_info[BX+4H]
             0FB0  03C1            ADD     AX,CX
             0FB2  13D7            ADC     DX,DI
             0FB4  3B560E          CMP     DX,[BP].sector+2H
             0FB7  7503            JNZ     $+5H
             0FB9  3B460C          CMP     AX,[BP].sector
             0FBC  7603            JBE     $+5H
             0FBE  E99000          JMP     @119
                                                   ; STATEMENT # 1661
             0FC1  2689470C        MOV     ES:block_info[BX+0CH],AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  72
                  ASSEMBLY LISTING OF OBJECT CODE


             0FC5  2689570E        MOV     ES:block_info[BX+0EH],DX
                                                   ; STATEMENT # 1662
             0FC9  C45E08          LES     BX,[BP].info
             0FCC  26FF4714        INC     ES:block_info[BX+14H]
                                                   ; STATEMENT # 1664
             0FD0  C45E08          LES     BX,[BP].info
             0FD3  266B771408      IMUL    SI,ES:block_info[BX+14H],8H
             0FD8  C43E4C02        LES     DI,FAT_cache
             0FDC  8BDF            MOV     BX,DI
             0FDE  268B5002        MOV     DX,ES:[BX].[SI+2H]
             0FE2  268B00          MOV     AX,ES:[BX].[SI]
             0FE5  81E80200        SUB     AX,2H
             0FE9  81DA0000        SBB     DX,0H
             0FED  8B3E3402        MOV     DI,sectors_per_cluster+2H
             0FF1  8B0E3202        MOV     CX,sectors_per_cluster
             0FF5  9A00000000      CALL    LQ_ULONG_MUL
             0FFA  03064002        ADD     AX,first_file_sector
             0FFE  13164202        ADC     DX,first_file_sector+2H
             1002  C45E08          LES     BX,[BP].info
             1005  268907          MOV     ES:block_info[BX],AX
             1008  26895702        MOV     ES:block_info[BX+2H],DX
                                                   ; STATEMENT # 1665
             100C  C45E08          LES     BX,[BP].info
             100F  266B771408      IMUL    SI,ES:block_info[BX+14H],8H
             1014  06              PUSH    ES      ; 1
             1015  C43E4C02        LES     DI,FAT_cache
             1019  87DF            XCHG    BX,DI
             101B  268B5006        MOV     DX,ES:[BX].[SI+6H]
             101F  268B4004        MOV     AX,ES:[BX].[SI+4H]
             1023  07              POP     ES      ; 1
             1024  26894504        MOV     ES:block_info[DI+4H],AX
             1028  26895506        MOV     ES:block_info[DI+6H],DX
                                                   ; STATEMENT # 1666
             102C  C45E08          LES     BX,[BP].info
             102F  268B7714        MOV     SI,ES:block_info[BX+14H]
             1033  46              INC     SI
             1034  6BF608          IMUL    SI,SI,8H
             1037  06              PUSH    ES      ; 1
             1038  C43E4C02        LES     DI,FAT_cache
             103C  87DF            XCHG    BX,DI
             103E  268B5002        MOV     DX,ES:[BX].[SI+2H]
             1042  268B00          MOV     AX,ES:[BX].[SI]
             1045  07              POP     ES      ; 1
             1046  26894508        MOV     ES:block_info[DI+8H],AX
             104A  2689550A        MOV     ES:block_info[DI+0AH],DX
                                                   ; STATEMENT # 1667
             104E  E919FF          JMP     @120
                           @119:
                                                   ; STATEMENT # 1670
             1051  C45E08          LES     BX,[BP].info
             1054  268B570E        MOV     DX,ES:block_info[BX+0EH]
             1058  268B470C        MOV     AX,ES:block_info[BX+0CH]
             105C  8B7E0E          MOV     DI,[BP].sector+2H
             105F  8B4E0C          MOV     CX,[BP].sector
             1062  3BD7            CMP     DX,DI
             1064  7502            JNZ     $+4H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  73
                  ASSEMBLY LISTING OF OBJECT CODE


             1066  3BC1            CMP     AX,CX
             1068  7603            JBE     $+5H
             106A  E91700          JMP     @121
             106D  26034704        ADD     AX,ES:block_info[BX+4H]
             1071  26135706        ADC     DX,ES:block_info[BX+6H]
             1075  3BD7            CMP     DX,DI
             1077  7502            JNZ     $+4H
             1079  3BC1            CMP     AX,CX
             107B  7703            JA      $+5H
             107D  E90400          JMP     @121
                                                   ; STATEMENT # 1672
             1080  C646F701        MOV     [BP].have_block,1H
                                                   ; STATEMENT # 1676
                           @121:
                                                   ; STATEMENT # 1677
                           @123:
             1084  827EF700        CMP     [BP].have_block,0H
             1088  7403            JZ      $+5H
             108A  E9DA00          JMP     @122
             108D  C45E08          LES     BX,[BP].info
             1090  26837F1400      CMP     ES:block_info[BX+14H],0H
             1095  7F03            JG      $+5H
             1097  E9CD00          JMP     @122
             109A  26817F0AFFFF    CMP     ES:block_info[BX+0AH],0FFFFH
             10A0  7506            JNZ     $+8H
             10A2  26817F08FFFF    CMP     ES:block_info[BX+8H],0FFFFH
             10A8  7503            JNZ     $+5H
             10AA  E9BA00          JMP     @122
             10AD  268B570E        MOV     DX,ES:block_info[BX+0EH]
             10B1  268B470C        MOV     AX,ES:block_info[BX+0CH]
             10B5  3B560E          CMP     DX,[BP].sector+2H
             10B8  7503            JNZ     $+5H
             10BA  3B460C          CMP     AX,[BP].sector
             10BD  7703            JA      $+5H
             10BF  E9A500          JMP     @122
                                                   ; STATEMENT # 1680
             10C2  26FF4F14        DEC     ES:block_info[BX+14H]
                                                   ; STATEMENT # 1681
             10C6  C45E08          LES     BX,[BP].info
             10C9  266B771408      IMUL    SI,ES:block_info[BX+14H],8H
             10CE  06              PUSH    ES      ; 1
             10CF  C43E4C02        LES     DI,FAT_cache
             10D3  87DF            XCHG    BX,DI
             10D5  268B5006        MOV     DX,ES:[BX].[SI+6H]
             10D9  268B4004        MOV     AX,ES:[BX].[SI+4H]
             10DD  07              POP     ES      ; 1
             10DE  2629450C        SUB     ES:block_info[DI+0CH],AX
             10E2  2619550E        SBB     ES:block_info[DI+0EH],DX
                                                   ; STATEMENT # 1683
             10E6  C45E08          LES     BX,[BP].info
             10E9  266B771408      IMUL    SI,ES:block_info[BX+14H],8H
             10EE  C43E4C02        LES     DI,FAT_cache
             10F2  8BDF            MOV     BX,DI
             10F4  268B5002        MOV     DX,ES:[BX].[SI+2H]
             10F8  268B00          MOV     AX,ES:[BX].[SI]
             10FB  81E80200        SUB     AX,2H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  74
                  ASSEMBLY LISTING OF OBJECT CODE


             10FF  81DA0000        SBB     DX,0H
             1103  8B3E3402        MOV     DI,sectors_per_cluster+2H
             1107  8B0E3202        MOV     CX,sectors_per_cluster
             110B  9A00000000      CALL    LQ_ULONG_MUL
             1110  03064002        ADD     AX,first_file_sector
             1114  13164202        ADC     DX,first_file_sector+2H
             1118  C45E08          LES     BX,[BP].info
             111B  268907          MOV     ES:block_info[BX],AX
             111E  26895702        MOV     ES:block_info[BX+2H],DX
                                                   ; STATEMENT # 1684
             1122  C45E08          LES     BX,[BP].info
             1125  266B771408      IMUL    SI,ES:block_info[BX+14H],8H
             112A  06              PUSH    ES      ; 1
             112B  C43E4C02        LES     DI,FAT_cache
             112F  87DF            XCHG    BX,DI
             1131  268B5006        MOV     DX,ES:[BX].[SI+6H]
             1135  268B4004        MOV     AX,ES:[BX].[SI+4H]
             1139  07              POP     ES      ; 1
             113A  26894504        MOV     ES:block_info[DI+4H],AX
             113E  26895506        MOV     ES:block_info[DI+6H],DX
                                                   ; STATEMENT # 1685
             1142  C45E08          LES     BX,[BP].info
             1145  268B7714        MOV     SI,ES:block_info[BX+14H]
             1149  46              INC     SI
             114A  6BF608          IMUL    SI,SI,8H
             114D  06              PUSH    ES      ; 1
             114E  C43E4C02        LES     DI,FAT_cache
             1152  87DF            XCHG    BX,DI
             1154  268B5002        MOV     DX,ES:[BX].[SI+2H]
             1158  268B00          MOV     AX,ES:[BX].[SI]
             115B  07              POP     ES      ; 1
             115C  26894508        MOV     ES:block_info[DI+8H],AX
             1160  2689550A        MOV     ES:block_info[DI+0AH],DX
                                                   ; STATEMENT # 1686
             1164  E91DFF          JMP     @123
                           @122:
                                                   ; STATEMENT # 1689
             1167  C45E08          LES     BX,[BP].info
             116A  268B570E        MOV     DX,ES:block_info[BX+0EH]
             116E  268B470C        MOV     AX,ES:block_info[BX+0CH]
             1172  8B7E0E          MOV     DI,[BP].sector+2H
             1175  8B4E0C          MOV     CX,[BP].sector
             1178  3BD7            CMP     DX,DI
             117A  7502            JNZ     $+4H
             117C  3BC1            CMP     AX,CX
             117E  7603            JBE     $+5H
             1180  E91700          JMP     @124
             1183  26034704        ADD     AX,ES:block_info[BX+4H]
             1187  26135706        ADC     DX,ES:block_info[BX+6H]
             118B  3BD7            CMP     DX,DI
             118D  7502            JNZ     $+4H
             118F  3BC1            CMP     AX,CX
             1191  7703            JA      $+5H
             1193  E90400          JMP     @124
                                                   ; STATEMENT # 1691
             1196  C646F701        MOV     [BP].have_block,1H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  75
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1696
                           @124:
             119A  827EF700        CMP     [BP].have_block,0H
             119E  7403            JZ      $+5H
             11A0  E94100          JMP     @125
                                                   ; STATEMENT # 1699
             11A3  C45E08          LES     BX,[BP].info
             11A6  268B570E        MOV     DX,ES:block_info[BX+0EH]
             11AA  268B470C        MOV     AX,ES:block_info[BX+0CH]
             11AE  3B560E          CMP     DX,[BP].sector+2H
             11B1  7503            JNZ     $+5H
             11B3  3B460C          CMP     AX,[BP].sector
             11B6  7703            JA      $+5H
             11B8  E92900          JMP     @126
                                                   ; STATEMENT # 1701
             11BB  268B5712        MOV     DX,ES:block_info[BX+12H]
             11BF  268B4710        MOV     AX,ES:block_info[BX+10H]
             11C3  26894708        MOV     ES:block_info[BX+8H],AX
             11C7  2689570A        MOV     ES:block_info[BX+0AH],DX
                                                   ; STATEMENT # 1703
             11CB  C45E08          LES     BX,[BP].info
             11CE  B80000          MOV     AX,0H
             11D1  26894704        MOV     ES:block_info[BX+4H],AX
             11D5  26894706        MOV     ES:block_info[BX+6H],AX
                                                   ; STATEMENT # 1704
             11D9  C45E08          LES     BX,[BP].info
             11DC  2689470C        MOV     ES:block_info[BX+0CH],AX
             11E0  2689470E        MOV     ES:block_info[BX+0EH],AX
                                                   ; STATEMENT # 1706
                           @126:
                                                   ; STATEMENT # 1709
                           @125:
                                                   ; STATEMENT # 1710
                           @128:
             11E4  827EF700        CMP     [BP].have_block,0H
             11E8  7403            JZ      $+5H
             11EA  E9D500          JMP     @127
             11ED  C45E08          LES     BX,[BP].info
             11F0  268B570A        MOV     DX,ES:block_info[BX+0AH]
             11F4  268B4708        MOV     AX,ES:block_info[BX+8H]
             11F8  81FAFFFF        CMP     DX,0FFFFH
             11FC  7504            JNZ     $+6H
             11FE  81F8FFFF        CMP     AX,0FFFFH
             1202  7503            JNZ     $+5H
             1204  E9BB00          JMP     @127
             1207  268B7F0E        MOV     DI,ES:block_info[BX+0EH]
             120B  268B4F0C        MOV     CX,ES:block_info[BX+0CH]
             120F  26034F04        ADD     CX,ES:block_info[BX+4H]
             1213  26137F06        ADC     DI,ES:block_info[BX+6H]
             1217  3B7E0E          CMP     DI,[BP].sector+2H
             121A  7503            JNZ     $+5H
             121C  3B4E0C          CMP     CX,[BP].sector
             121F  7603            JBE     $+5H
             1221  E99E00          JMP     @127
                                                   ; STATEMENT # 1713
             1224  8D4EF8          LEA     CX,[BP].e
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  76
                  ASSEMBLY LISTING OF OBJECT CODE


             1227  1E              PUSH    DS      ; 1
             1228  51              PUSH    CX      ; 2
             1229  52              PUSH    DX      ; 3
             122A  50              PUSH    AX      ; 4
             122B  E89800          CALL    get_contig_sectors
             122E  81C40800        ADD     SP,8H
             1232  C45E08          LES     BX,[BP].info
             1235  26894708        MOV     ES:block_info[BX+8H],AX
             1239  2689570A        MOV     ES:block_info[BX+0AH],DX
                                                   ; STATEMENT # 1717
             123D  C45E08          LES     BX,[BP].info
             1240  26817F120000    CMP     ES:block_info[BX+12H],0H
             1246  7506            JNZ     $+8H
             1248  26817F100000    CMP     ES:block_info[BX+10H],0H
             124E  7403            JZ      $+5H
             1250  E91200          JMP     @129
                                                   ; STATEMENT # 1719
             1253  8B164602        MOV     DX,root_start_sector+2H
             1257  8B064402        MOV     AX,root_start_sector
             125B  268907          MOV     ES:block_info[BX],AX
             125E  26895702        MOV     ES:block_info[BX+2H],DX
                                                   ; STATEMENT # 1720
             1262  E92D00          JMP     @130
                           @129:
                                                   ; STATEMENT # 1722
             1265  8B56FA          MOV     DX,[BP].e+2H
             1268  8B46F8          MOV     AX,[BP].e
             126B  81E80200        SUB     AX,2H
             126F  81DA0000        SBB     DX,0H
             1273  8B3E3402        MOV     DI,sectors_per_cluster+2H
             1277  8B0E3202        MOV     CX,sectors_per_cluster
             127B  9A00000000      CALL    LQ_ULONG_MUL
             1280  03064002        ADD     AX,first_file_sector
             1284  13164202        ADC     DX,first_file_sector+2H
             1288  C45E08          LES     BX,[BP].info
             128B  268907          MOV     ES:block_info[BX],AX
             128E  26895702        MOV     ES:block_info[BX+2H],DX
                           @130:
                                                   ; STATEMENT # 1725
             1292  C45E08          LES     BX,[BP].info
             1295  268B5706        MOV     DX,ES:block_info[BX+6H]
             1299  268B4704        MOV     AX,ES:block_info[BX+4H]
             129D  2601470C        ADD     ES:block_info[BX+0CH],AX
             12A1  2611570E        ADC     ES:block_info[BX+0EH],DX
                                                   ; STATEMENT # 1726
             12A5  8B56FE          MOV     DX,[BP].e+6H
             12A8  8B46FC          MOV     AX,[BP].e+4H
             12AB  C45E08          LES     BX,[BP].info
             12AE  26894704        MOV     ES:block_info[BX+4H],AX
             12B2  26895706        MOV     ES:block_info[BX+6H],DX
                                                   ; STATEMENT # 1729
             12B6  C45E08          LES     BX,[BP].info
             12B9  26C74714FFFF    MOV     ES:block_info[BX+14H],0FFFFH
                                                   ; STATEMENT # 1730
             12BF  E922FF          JMP     @128
                           @127:
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  77
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1735
             12C2  C9              LEAVE
             12C3  5F              POP     DI
             12C4  5E              POP     SI
             12C5  C3              RET
                                                   ; STATEMENT # 1737
                           get_block_info      ENDP
                                                   ; STATEMENT # 1796
                           get_contig_sectors      PROC NEAR
             12C6  56              PUSH    SI
             12C7  57              PUSH    DI
             12C8  C80E0200        ENTER   20EH,0H
                           @131:
                                                   ; STATEMENT # 1805
             12CC  C686F3FD01      MOV     [BP].contig,1H
                                                   ; STATEMENT # 1806
             12D1  C686F2FD00      MOV     [BP].error,0H
                                                   ; STATEMENT # 1811
             12D6  817E0A0000      CMP     [BP].cluster+2H,0H
             12DB  7505            JNZ     $+7H
             12DD  817E080000      CMP     [BP].cluster,0H
             12E2  7403            JZ      $+5H
             12E4  E93100          JMP     @132
                                                   ; STATEMENT # 1814
             12E7  8B164602        MOV     DX,root_start_sector+2H
             12EB  8B064402        MOV     AX,root_start_sector
             12EF  C45E0C          LES     BX,[BP].entry
             12F2  268907          MOV     ES:cache_entry[BX],AX
             12F5  26895702        MOV     ES:cache_entry[BX+2H],DX
                                                   ; STATEMENT # 1815
             12F9  8B164A02        MOV     DX,root_dir_size+2H
             12FD  8B064802        MOV     AX,root_dir_size
             1301  C45E0C          LES     BX,[BP].entry
             1304  26894704        MOV     ES:cache_entry[BX+4H],AX
             1308  26895706        MOV     ES:cache_entry[BX+6H],DX
                                                   ; STATEMENT # 1816
             130C  B8FFFF          MOV     AX,0FFFFH
             130F  8946F4          MOV     [BP].next,AX
             1312  8946F6          MOV     [BP].next+2H,AX
                                                   ; STATEMENT # 1818
             1315  E9EA01          JMP     @133
                           @132:
             1318  817E0AFFFF      CMP     [BP].cluster+2H,0FFFFH
             131D  7505            JNZ     $+7H
             131F  817E08FFFF      CMP     [BP].cluster,0FFFFH
             1324  7403            JZ      $+5H
             1326  E92400          JMP     @134
                                                   ; STATEMENT # 1821
             1329  C45E0C          LES     BX,[BP].entry
             132C  B80000          MOV     AX,0H
             132F  268907          MOV     ES:cache_entry[BX],AX
             1332  26894702        MOV     ES:cache_entry[BX+2H],AX
                                                   ; STATEMENT # 1822
             1336  C45E0C          LES     BX,[BP].entry
             1339  26894704        MOV     ES:cache_entry[BX+4H],AX
             133D  26894706        MOV     ES:cache_entry[BX+6H],AX
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  78
                  ASSEMBLY LISTING OF OBJECT CODE


                                                   ; STATEMENT # 1823
             1341  B8FFFF          MOV     AX,0FFFFH
             1344  8946F4          MOV     [BP].next,AX
             1347  8946F6          MOV     [BP].next+2H,AX
                                                   ; STATEMENT # 1825
             134A  E9B501          JMP     @135
                           @134:
                                                   ; STATEMENT # 1829
             134D  8B560A          MOV     DX,[BP].cluster+2H
             1350  8B4608          MOV     AX,[BP].cluster
             1353  C45E0C          LES     BX,[BP].entry
             1356  268907          MOV     ES:cache_entry[BX],AX
             1359  26895702        MOV     ES:cache_entry[BX+2H],DX
                                                   ; STATEMENT # 1831
             135D  C45E0C          LES     BX,[BP].entry
             1360  B80000          MOV     AX,0H
             1363  26894704        MOV     ES:cache_entry[BX+4H],AX
             1367  26894706        MOV     ES:cache_entry[BX+6H],AX
                                                   ; STATEMENT # 1835
             136B  8B063602        MOV     AX,clusters_per_sector
             136F  99              CWD
             1370  8BC8            MOV     CX,AX
             1372  8B7E0A          MOV     DI,[BP].cluster+2H
             1375  8B4608          MOV     AX,[BP].cluster
             1378  87D7            XCHG    DX,DI
             137A  51              PUSH    CX      ; 1
             137B  57              PUSH    DI      ; 2
             137C  9A00000000      CALL    LQ_ULONG_DIV
             1381  03063C02        ADD     AX,first_FAT_sector
             1385  13163E02        ADC     DX,first_FAT_sector+2H
             1389  8946FC          MOV     [BP].s,AX
             138C  8956FE          MOV     [BP].s+2H,DX
                                                   ; STATEMENT # 1837
             138F  5F              POP     DI      ; 2
             1390  59              POP     CX      ; 1
             1391  8B760A          MOV     SI,[BP].cluster+2H
             1394  8B4608          MOV     AX,[BP].cluster
             1397  8BD6            MOV     DX,SI
             1399  9A00000000      CALL    LQ_ULONG_DIV
             139E  897EF8          MOV     [BP].c,DI
             13A1  8976FA          MOV     [BP].c+2H,SI
                                                   ; STATEMENT # 1839
             13A4  8D86F4FD        LEA     AX,[BP].sector
             13A8  1E              PUSH    DS      ; 1
             13A9  50              PUSH    AX      ; 2
             13AA  680100          PUSH    1H
             13AD  FF76FE          PUSH    [BP].s+2H; 4
             13B0  FF76FC          PUSH    [BP].s  ; 5
             13B3  E80000          CALL    get_blocks
             13B6  81C40A00        ADD     SP,0AH
             13BA  81F80100        CMP     AX,1H
             13BE  B80100          MOV     AX,1H
             13C1  7501            JNZ     $+3H
             13C3  48              DEC     AX
             13C4  8886F2FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 1842
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  79
                  ASSEMBLY LISTING OF OBJECT CODE


                           @137:
             13C8  82BEF3FD00      CMP     [BP].contig,0H
             13CD  7503            JNZ     $+5H
             13CF  E9E700          JMP     @136
             13D2  82BEF2FD00      CMP     [BP].error,0H
             13D7  7403            JZ      $+5H
             13D9  E9DD00          JMP     @136
                                                   ; STATEMENT # 1845
             13DC  8B063602        MOV     AX,clusters_per_sector
             13E0  99              CWD
             13E1  3B56FA          CMP     DX,[BP].c+2H
             13E4  7503            JNZ     $+5H
             13E6  3B46F8          CMP     AX,[BP].c
             13E9  7603            JBE     $+5H
             13EB  E93D00          JMP     @138
                                                   ; STATEMENT # 1847
             13EE  8B56FE          MOV     DX,[BP].s+2H
             13F1  8B46FC          MOV     AX,[BP].s
             13F4  81C00100        ADD     AX,1H
             13F8  81D20000        ADC     DX,0H
             13FC  8946FC          MOV     [BP].s,AX
             13FF  8956FE          MOV     [BP].s+2H,DX
                                                   ; STATEMENT # 1849
             1402  BF0000          MOV     DI,0H
             1405  897EF8          MOV     [BP].c,DI
             1408  897EFA          MOV     [BP].c+2H,DI
                                                   ; STATEMENT # 1851
             140B  8D8EF4FD        LEA     CX,[BP].sector
             140F  1E              PUSH    DS      ; 1
             1410  51              PUSH    CX      ; 2
             1411  680100          PUSH    1H
             1414  52              PUSH    DX      ; 4
             1415  50              PUSH    AX      ; 5
             1416  E80000          CALL    get_blocks
             1419  81C40A00        ADD     SP,0AH
             141D  81F80100        CMP     AX,1H
             1421  B80100          MOV     AX,1H
             1424  7501            JNZ     $+3H
             1426  48              DEC     AX
             1427  8886F2FD        MOV     [BP].error,AL
                                                   ; STATEMENT # 1855
                           @138:
             142B  823ED60700      CMP     fat16,0H
             1430  7503            JNZ     $+5H
             1432  E91A00          JMP     @139
                                                   ; STATEMENT # 1857
             1435  8B56FA          MOV     DX,[BP].c+2H
             1438  8B76F8          MOV     SI,[BP].c
             143B  D1E6            SHL     SI,1
             143D  D1D2            RCL     DX,1
             143F  8B82F4FD        MOV     AX,[BP].sector[SI]
             1443  BA0000          MOV     DX,0H
             1446  8946F4          MOV     [BP].next,AX
             1449  8956F6          MOV     [BP].next+2H,DX
                                                   ; STATEMENT # 1858
             144C  E92000          JMP     @140
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  80
                  ASSEMBLY LISTING OF OBJECT CODE


                           @139:
                                                   ; STATEMENT # 1860
             144F  B80400          MOV     AX,4H
             1452  99              CWD
             1453  8B7EFA          MOV     DI,[BP].c+2H
             1456  8B4EF8          MOV     CX,[BP].c
             1459  9A00000000      CALL    LQ_ULONG_MUL
             145E  8D9EF4FD        LEA     BX,[BP].sector
             1462  8BF0            MOV     SI,AX
             1464  8B5002          MOV     DX,[BX].[SI+2H]
             1467  8B00            MOV     AX,[BX].[SI]
             1469  8946F4          MOV     [BP].next,AX
             146C  8956F6          MOV     [BP].next+2H,DX
                           @140:
                                                   ; STATEMENT # 1864
             146F  8B560A          MOV     DX,[BP].cluster+2H
             1472  8B4608          MOV     AX,[BP].cluster
             1475  81C00100        ADD     AX,1H
             1479  81D20000        ADC     DX,0H
             147D  3B56F6          CMP     DX,[BP].next+2H
             1480  7503            JNZ     $+5H
             1482  3B46F4          CMP     AX,[BP].next
             1485  B80100          MOV     AX,1H
             1488  7401            JZ      $+3H
             148A  48              DEC     AX
             148B  8886F3FD        MOV     [BP].contig,AL
                                                   ; STATEMENT # 1867
             148F  C45E0C          LES     BX,[BP].entry
             1492  8B163402        MOV     DX,sectors_per_cluster+2H
             1496  8B063202        MOV     AX,sectors_per_cluster
             149A  26014704        ADD     ES:cache_entry[BX+4H],AX
             149E  26115706        ADC     ES:cache_entry[BX+6H],DX
                                                   ; STATEMENT # 1870
             14A2  8146080100      ADD     [BP].cluster,1H
             14A7  81560A0000      ADC     [BP].cluster+2H,0H
                                                   ; STATEMENT # 1872
             14AC  8146F80100      ADD     [BP].c,1H
             14B1  8156FA0000      ADC     [BP].c+2H,0H
                                                   ; STATEMENT # 1873
             14B6  E90FFF          JMP     @137
                           @136:
                                                   ; STATEMENT # 1878
             14B9  82BEF2FD00      CMP     [BP].error,0H
             14BE  7403            JZ      $+5H
             14C0  E93600          JMP     @142
             14C3  823ED60700      CMP     fat16,0H
             14C8  7503            JNZ     $+5H
             14CA  E91100          JMP     @143
             14CD  817EF60000      CMP     [BP].next+2H,0H
             14D2  7505            JNZ     $+7H
             14D4  817EF4F7FF      CMP     [BP].next,0FFF7H
             14D9  7203            JB      $+5H
             14DB  E91B00          JMP     @142
                           @143:
             14DE  823ED60700      CMP     fat16,0H
             14E3  7403            JZ      $+5H
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  81
                  ASSEMBLY LISTING OF OBJECT CODE


             14E5  E91A00          JMP     @141
             14E8  817EF6FFFF      CMP     [BP].next+2H,0FFFFH
             14ED  7505            JNZ     $+7H
             14EF  817EF4F7FF      CMP     [BP].next,0FFF7H
             14F4  7303            JAE     $+5H
             14F6  E90900          JMP     @141
                           @142:
                                                   ; STATEMENT # 1881
             14F9  B8FFFF          MOV     AX,0FFFFH
             14FC  8946F4          MOV     [BP].next,AX
             14FF  8946F6          MOV     [BP].next+2H,AX
                                                   ; STATEMENT # 1883
                           @141:
                           @135:
                           @133:
                                                   ; STATEMENT # 1887
             1502  8B56F6          MOV     DX,[BP].next+2H
             1505  8B46F4          MOV     AX,[BP].next
             1508  C9              LEAVE
             1509  5F              POP     DI
             150A  5E              POP     SI
             150B  C3              RET
                                                   ; STATEMENT # 1889
                           get_contig_sectors      ENDP
                                                   ; STATEMENT # 1934
                           init_dir_stack      PROC NEAR
             150C  56              PUSH    SI
             150D  57              PUSH    DI
             150E  55              PUSH    BP
             150F  8BEC            MOV     BP,SP
                           @144:
                                                   ; STATEMENT # 1941
             1511  C606D70700      MOV     dirnames,0H
                                                   ; STATEMENT # 1944
             1516  B80000          MOV     AX,0H
             1519  89065002        MOV     dirclusterstack,AX
             151D  89065202        MOV     dirclusterstack+2H,AX
                                                   ; STATEMENT # 1945
             1521  C706A8040000    MOV     dirnamestack,0H
                                                   ; STATEMENT # 1948
             1527  C706D405FFFF    MOV     dirstack_ptr,0FFFFH
                                                   ; STATEMENT # 1952
             152D  5D              POP     BP
             152E  5F              POP     DI
             152F  5E              POP     SI
             1530  C3              RET
                                                   ; STATEMENT # 1954
                           init_dir_stack      ENDP
                                                   ; STATEMENT # 2002
                           new_directory      PROC NEAR
             1532  56              PUSH    SI
             1533  57              PUSH    DI
             1534  55              PUSH    BP
             1535  8BEC            MOV     BP,SP
                           @145:
                                                   ; STATEMENT # 2009
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  82
                  ASSEMBLY LISTING OF OBJECT CODE


             1537  8B1ED405        MOV     BX,dirstack_ptr
             153B  09DB            OR      BX,BX
             153D  7903            JNS     $+5H
             153F  E92C00          JMP     @146
             1542  6BF304          IMUL    SI,BX,4H
             1545  8B945202        MOV     DX,dirclusterstack[SI+2H]
             1549  8B845002        MOV     AX,dirclusterstack[SI]
             154D  3B162E02        CMP     DX,cur_info+12H
             1551  7504            JNZ     $+6H
             1553  3B062C02        CMP     AX,cur_info+10H
             1557  7403            JZ      $+5H
             1559  E91200          JMP     @146
                                                   ; STATEMENT # 2013
             155C  D1E3            SAL     BX,1
             155E  8B9FA804        MOV     BX,dirnamestack[BX]
             1562  C687D70700      MOV     dirnames[BX],0H
                                                   ; STATEMENT # 2015
             1567  FF0ED405        DEC     dirstack_ptr
                                                   ; STATEMENT # 2017
             156B  E97600          JMP     @147
                           @146:
                                                   ; STATEMENT # 2023
             156E  813ED4059500    CMP     dirstack_ptr,95H
             1574  7C03            JL      $+5H
             1576  E96B00          JMP     @148
             1579  B8D707          MOV     AX,OFFSET(dirnames)
             157C  1E              PUSH    DS      ; 1
             157D  50              PUSH    AX      ; 2
             157E  E80000          CALL    strlen_
             1581  81C40400        ADD     SP,4H
             1585  50              PUSH    AX      ; 1
             1586  B9D605          MOV     CX,OFFSET(dirname)
             1589  1E              PUSH    DS      ; 2
             158A  51              PUSH    CX      ; 3
             158B  E80000          CALL    strlen_
             158E  81C40400        ADD     SP,4H
             1592  59              POP     CX      ; 1
             1593  03C1            ADD     AX,CX
             1595  81F82C01        CMP     AX,12CH
             1599  7C03            JL      $+5H
             159B  E94600          JMP     @148
                                                   ; STATEMENT # 2026
             159E  8B1ED405        MOV     BX,dirstack_ptr
             15A2  43              INC     BX
             15A3  891ED405        MOV     dirstack_ptr,BX
                                                   ; STATEMENT # 2028
             15A7  6BDB04          IMUL    BX,BX,4H
             15AA  8B161402        MOV     DX,dir_info+12H
             15AE  8B061202        MOV     AX,dir_info+10H
             15B2  89875002        MOV     dirclusterstack[BX],AX
             15B6  89975202        MOV     dirclusterstack[BX+2H],DX
                                                   ; STATEMENT # 2030
             15BA  B8D707          MOV     AX,OFFSET(dirnames)
             15BD  1E              PUSH    DS      ; 1
             15BE  50              PUSH    AX      ; 2
             15BF  E80000          CALL    strlen_
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  83
                  ASSEMBLY LISTING OF OBJECT CODE


             15C2  81C40400        ADD     SP,4H
             15C6  8B1ED405        MOV     BX,dirstack_ptr
             15CA  D1E3            SAL     BX,1
             15CC  8987A804        MOV     dirnamestack[BX],AX
                                                   ; STATEMENT # 2031
             15D0  B8D605          MOV     AX,OFFSET(dirname)
             15D3  1E              PUSH    DS      ; 1
             15D4  50              PUSH    AX      ; 2
             15D5  B8D707          MOV     AX,OFFSET(dirnames)
             15D8  1E              PUSH    DS      ; 3
             15D9  50              PUSH    AX      ; 4
             15DA  E80000          CALL    strcat_
             15DD  81C40800        ADD     SP,8H
                                                   ; STATEMENT # 2033
             15E1  E90000          JMP     @149
                           @148:
                                                   ; STATEMENT # 2037
                           @149:
                                                   ; STATEMENT # 2038
                           @147:
                                                   ; STATEMENT # 2042
             15E4  5D              POP     BP
             15E5  5F              POP     DI
             15E6  5E              POP     SI
             15E7  C3              RET
                                                   ; STATEMENT # 2044
                           new_directory      ENDP
                                                   ; STATEMENT # 2079
                           get_dir_tos_name      PROC NEAR
             15E8  56              PUSH    SI
             15E9  57              PUSH    DI
             15EA  C8040000        ENTER   4H,0H
                           @150:
                                                   ; STATEMENT # 2086
             15EE  8B1ED405        MOV     BX,dirstack_ptr
             15F2  09DB            OR      BX,BX
             15F4  7903            JNS     $+5H
             15F6  E91300          JMP     @151
                                                   ; STATEMENT # 2089
             15F9  D1E3            SAL     BX,1
             15FB  8B9FA804        MOV     BX,dirnamestack[BX]
             15FF  8D87D707        LEA     AX,dirnames[BX]
             1603  8946FC          MOV     [BP].name,AX
             1606  8C5EFE          MOV     [BP].name+2H,DS
                                                   ; STATEMENT # 2091
             1609  E90E00          JMP     @152
                           @151:
                                                   ; STATEMENT # 2095
             160C  C606D70700      MOV     dirnames,0H
                                                   ; STATEMENT # 2097
             1611  B8D707          MOV     AX,OFFSET(dirnames)
             1614  8946FC          MOV     [BP].name,AX
             1617  8C5EFE          MOV     [BP].name+2H,DS
                                                   ; STATEMENT # 2098
                           @152:
                                                   ; STATEMENT # 2102
iC-86  COMPILER   FATUTIL                                                                    04/21/;6 17:34:29  PAGE  84
                  ASSEMBLY LISTING OF OBJECT CODE


             161A  C446FC          LES     AX,[BP].name
             161D  8CC2            MOV     DX,ES
             161F  C9              LEAVE
             1620  5F              POP     DI
             1621  5E              POP     SI
             1622  C3              RET
                                                   ; STATEMENT # 2104
                           get_dir_tos_name      ENDP
                                                   ; STATEMENT # 2138
                           get_dir_tos_sector      PROC NEAR
             1624  56              PUSH    SI
             1625  57              PUSH    DI
             1626  C8040000        ENTER   4H,0H
                           @153:
                                                   ; STATEMENT # 2145
             162A  8B1ED405        MOV     BX,dirstack_ptr
             162E  09DB            OR      BX,BX
             1630  7903            JNS     $+5H
             1632  E91400          JMP     @154
                                                   ; STATEMENT # 2148
             1635  6BDB04          IMUL    BX,BX,4H
             1638  8B975202        MOV     DX,dirclusterstack[BX+2H]
             163C  8B875002        MOV     AX,dirclusterstack[BX]
             1640  8946FC          MOV     [BP].c,AX
             1643  8956FE          MOV     [BP].c+2H,DX
                                                   ; STATEMENT # 2150
             1646  E90900          JMP     @155
                           @154:
                                                   ; STATEMENT # 2153
             1649  B80000          MOV     AX,0H
             164C  8946FC          MOV     [BP].c,AX
             164F  8946FE          MOV     [BP].c+2H,AX
                                                   ; STATEMENT # 2154
                           @155:
                                                   ; STATEMENT # 2158
             1652  8B56FE          MOV     DX,[BP].c+2H
             1655  8B46FC          MOV     AX,[BP].c
             1658  C9              LEAVE
             1659  5F              POP     DI
             165A  5E              POP     SI
             165B  C3              RET
                                                   ; STATEMENT # 2160
                           get_dir_tos_sector      ENDP



MODULE INFORMATION:

     CODE AREA SIZE               = 165CH   5724D
     CONSTANT AREA SIZE           = 0000H      0D
     DATA AREA SIZE               = 0903H   2307D
     MAXIMUM STACK SIZE           = 0228H    552D

iC-86 COMPILATION COMPLETE.      0 WARNINGS,     0 ERRORS
